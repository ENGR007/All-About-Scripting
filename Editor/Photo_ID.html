<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Offline AI ID / Passport Photo (MODNet)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- ONNX Runtime Web (loads the ONNX model from memory) -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020514;
      color: #f5f7ff;
    }
    .app {
      max-width: 1100px;
      margin: 16px auto 32px;
      padding: 12px;
    }
    h1 {
      margin: 0 0 6px;
      font-size: 1.4rem;
      text-align: center;
    }
    .subtitle {
      text-align: center;
      font-size: 0.85rem;
      color: #a7b3d9;
      margin-bottom: 12px;
    }
    .shell {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .panel {
      background: #141b2f;
      border-radius: 8px;
      border: 1px solid #253250;
      padding: 10px;
      flex: 1 1 260px;
      min-width: 0;
    }
    .panel h2 {
      margin: 0 0 6px;
      font-size: 0.95rem;
      color: #ffb84d;
    }
    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      margin-bottom: 6px;
    }
    button,
    select,
    input[type="number"],
    input[type="file"] {
      font: inherit;
      border-radius: 6px;
      border: 1px solid #27355a;
      padding: 5px 8px;
      background: #1b2542;
      color: #f5f7ff;
      outline: none;
    }
    button {
      cursor: pointer;
      background: linear-gradient(135deg, #ffb84d, #ff9f1c);
      border-color: transparent;
      color: #1b1020;
      font-weight: 600;
      white-space: nowrap;
    }
    button.secondary {
      background: #1b2542;
      color: #d0daf8;
      border-color: #27355a;
      font-weight: 500;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
    video,
    canvas {
      width: 100%;
      max-height: 360px;
      border-radius: 6px;
      background: #000;
      border: 1px solid #27355a;
    }
    label {
      font-size: 0.8rem;
      color: #a7b3d9;
    }
    .hint {
      font-size: 0.75rem;
      color: #9ba6ce;
      margin-top: 4px;
    }
    .status {
      margin-top: 6px;
      font-size: 0.78rem;
      color: #a7b3d9;
    }
    .status .ok {
      color: #5bd38a;
      font-weight: 600;
    }
    .status .err {
      color: #ff4d6a;
      font-weight: 600;
    }
    .slider-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 4px;
    }
    .slider-row span {
      flex: 0 0 70px;
      font-size: 0.78rem;
      color: #a7b3d9;
    }
    .slider-row input[type="range"] {
      flex: 1;
    }
    @media (max-width: 880px) {
      .shell { flex-direction: column; }
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>Offline AI ID / Passport Photo (MODNet)</h1>
    <div class="subtitle">
      High-quality portrait matting with MODNet (model embedded as Base64), automatic white background, and ID sizes.
    </div>

    <div class="shell">
      <!-- LEFT: SOURCE -->
      <div class="panel">
        <h2>1. Source (Camera / Gallery)</h2>

        <div class="controls-row">
          <button id="startCameraBtn">Start Camera</button>
          <button id="captureBtn" disabled>Capture</button>
        </div>

        <video id="video" autoplay playsinline></video>

        <div class="controls-row" style="margin-top:6px;">
          <label for="fileInput">Or choose from Photos / Files:</label>
          <input type="file" id="fileInput" accept="image/*" />
        </div>

        <div class="hint">
          Tip: Use portrait orientation, good lighting, and face centered. Background can be messy &mdash; AI will clean it.
        </div>
      </div>

      <!-- CENTER: EDITOR -->
      <div class="panel">
        <h2>2. AI White Background + Enhancements</h2>

        <canvas id="editCanvas" width="480" height="640"></canvas>

        <div class="hint" id="aiHint">
          Loading MODNet model from Base64… please wait a moment.
        </div>

        <div style="margin-top:8px;">
          <div class="controls-row">
            <button id="quickEnhanceBtn" class="secondary">Quick Enhance</button>
            <button id="resetBtn" class="secondary">Reset</button>
          </div>

          <div class="slider-row">
            <span>Brightness</span>
            <input type="range" id="brightnessSlider" min="-80" max="80" value="0" />
          </div>
          <div class="slider-row">
            <span>Contrast</span>
            <input type="range" id="contrastSlider" min="-80" max="80" value="0" />
          </div>

          <div class="controls-row" style="margin-top:6px;">
            <button id="applyAdjustBtn" class="secondary">Apply Adjustments</button>
            <button id="clearAdjustBtn" class="secondary">Clear Sliders</button>
          </div>
        </div>
      </div>

      <!-- RIGHT: OUTPUT -->
      <div class="panel">
        <h2>3. ID / Passport Output</h2>

        <div class="controls-row">
          <label for="sizePreset">Size preset:</label>
          <select id="sizePreset">
            <option value="original">Same as canvas</option>
            <option value="passport">Passport 35×45 mm (~413×531 px @ 300 dpi)</option>
            <option value="us2x2">US 2×2 in (600×600 px @ 300 dpi)</option>
            <option value="inch1x1">1×1 in (300×300 px)</option>
            <option value="custom">Custom (pixels)</option>
          </select>
        </div>

        <div class="controls-row" id="customSizeRow" style="display:none;">
          <label>Custom:</label>
          <input type="number" id="customWidth" placeholder="Width" min="50" max="3000" style="width:90px;">
          <input type="number" id="customHeight" placeholder="Height" min="50" max="3000" style="width:90px;">
        </div>

        <div class="hint">
          Common sizes @300 dpi:<br>
          &bull; Passport 35×45 mm → ~413×531 px<br>
          &bull; 2×2 in → 600×600 px<br>
          &bull; 1×1 in → 300×300 px
        </div>

        <div class="controls-row" style="margin-top:10px;">
          <button id="downloadBtn">Download Final JPEG</button>
        </div>

        <div class="status" id="statusMsg">
          Waiting for MODNet to finish loading…
        </div>

        <div class="hint" style="margin-top:8px;">
          Export uses a “cover fit”: photo fills the chosen size and is centered. Background is pure white.
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== 1. PLACE YOUR BASE64 MODEL STRING HERE =====
    // Replace the placeholder with the real Base64 from modnet_base64.txt
    const MODNET_BASE64 = "PASTE_FULL_BASE64_STRING_HERE";

    // ===== 2. GENERAL DOM + STATE =====
    const video = document.getElementById("video");
    const startCameraBtn = document.getElementById("startCameraBtn");
    const captureBtn = document.getElementById("captureBtn");
    const fileInput = document.getElementById("fileInput");
    const canvas = document.getElementById("editCanvas");
    const ctx = canvas.getContext("2d");

    const quickEnhanceBtn = document.getElementById("quickEnhanceBtn");
    const resetBtn = document.getElementById("resetBtn");
    const brightnessSlider = document.getElementById("brightnessSlider");
    const contrastSlider = document.getElementById("contrastSlider");
    const applyAdjustBtn = document.getElementById("applyAdjustBtn");
    const clearAdjustBtn = document.getElementById("clearAdjustBtn");

    const sizePreset = document.getElementById("sizePreset");
    const customSizeRow = document.getElementById("customSizeRow");
    const customWidth = document.getElementById("customWidth");
    const customHeight = document.getElementById("customHeight");
    const downloadBtn = document.getElementById("downloadBtn");
    const statusMsg = document.getElementById("statusMsg");
    const aiHint = document.getElementById("aiHint");

    let stream = null;
    let hasImage = false;
    let originalImageData = null;
    let originalWidth = canvas.width;
    let originalHeight = canvas.height;

    let modnetSession = null;
    let aiReady = false;

    function setStatus(message, type) {
      if (!statusMsg) return;
      if (type === "ok") {
        statusMsg.innerHTML = '<span class="ok">✔</span> ' + message;
      } else if (type === "err") {
        statusMsg.innerHTML = '<span class="err">⚠</span> ' + message;
      } else {
        statusMsg.textContent = message;
      }
    }

    // ===== 3. DECODE BASE64 → ArrayBuffer → ONNX SESSION =====
    function base64ToUint8Array(base64) {
      const binary = atob(base64);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
    }

    async function loadModNetModel() {
      try {
        aiHint.textContent = "Decoding embedded MODNet model…";
        const modelBytes = base64ToUint8Array(MODNET_BASE64);
        aiHint.textContent = "Creating ONNX Runtime session…";
        modnetSession = await ort.InferenceSession.create(modelBytes.buffer, {
          executionProviders: ["wasm", "webgl"]
        });
        aiReady = true;
        aiHint.textContent = "MODNet ready. New photos will get white background automatically.";
        setStatus("MODNet loaded from Base64. Capture or upload a photo.", "ok");
      } catch (e) {
        console.error(e);
        aiHint.textContent = "Failed to load MODNet. Check Base64 and model.";
        setStatus("Failed to load MODNet model. Background will not be auto-removed.", "err");
      }
    }

    // ===== 4. CAMERA HANDLING =====
    async function startCamera() {
      try {
        if (stream) return;
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "user" },
          audio: false
        });
        video.srcObject = stream;
        captureBtn.disabled = false;
        setStatus("Camera ready. Tap Capture.", "ok");
      } catch (err) {
        console.error(err);
        setStatus("Cannot access camera. Use file upload instead.", "err");
      }
    }

    function capturePhoto() {
      if (!video.videoWidth || !video.videoHeight) {
        setStatus("Camera not ready yet. Try again.", "err");
        return;
      }
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      onNewImage();
    }

    // ===== 5. FILE UPLOAD =====
    function handleFileUpload(e) {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (ev) => {
        const img = new Image();
        img.onload = () => {
          const maxSide = 900;
          let w = img.width;
          let h = img.height;
          const scale = Math.min(maxSide / w, maxSide / h, 1);
          w = Math.round(w * scale);
          h = Math.round(h * scale);
          canvas.width = w;
          canvas.height = h;
          ctx.drawImage(img, 0, 0, w, h);
          onNewImage();
        };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    }

    // ===== 6. WHEN NEW IMAGE ARRIVES =====
    async function onNewImage() {
      hasImage = true;
      originalWidth = canvas.width;
      originalHeight = canvas.height;
      originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      resetSlidersOnly();

      if (aiReady && modnetSession) {
        setStatus("Running MODNet to remove background…", "");
        await applyModNetWhiteBackground();
        setStatus("Background set to pure white using MODNet.", "ok");
      } else {
        setStatus("MODNet not ready. Image loaded as-is.", "err");
      }
    }

    // ===== 7. MODNET MATTE + WHITE BACKGROUND =====
    async function applyModNetWhiteBackground() {
      const srcW = canvas.width;
      const srcH = canvas.height;

      // Typical MODNet input size is 512x512; adjust if your model requires different.
      const netW = 512;
      const netH = 512;

      const tmp = document.createElement("canvas");
      tmp.width = netW;
      tmp.height = netH;
      const tctx = tmp.getContext("2d");
      tctx.drawImage(canvas, 0, 0, netW, netH);

      const imgData = tctx.getImageData(0, 0, netW, netH);
      const data = imgData.data;

      // Convert RGBA [0..255] → normalized RGB [0..1], CHW
      const inputData = new Float32Array(1 * 3 * netH * netW);
      let idx = 0;
      for (let y = 0; y < netH; y++) {
        for (let x = 0; x < netW; x++) {
          const i = (y * netW + x) * 4;
          const r = data[i] / 255;
          const g = data[i + 1] / 255;
          const b = data[i + 2] / 255;

          inputData[idx] = r;                         // R
          inputData[idx + netW * netH] = g;           // G
          inputData[idx + 2 * netW * netH] = b;       // B
          idx++;
        }
      }

      // NOTE: You may need to change input name depending on model, e.g. "input", "data", etc.
      const inputName = modnetSession.inputNames[0];
      const feeds = {};
      feeds[inputName] = new ort.Tensor("float32", inputData, [1, 3, netH, netW]);

      const results = await modnetSession.run(feeds);
      const outputName = modnetSession.outputNames[0];
      const out = results[outputName];
      const alphaData = out.data; // Float32, 1 x 1 x H x W or 1 x H x W

      // Determine output shape
      const dims = out.dims;
      let aH, aW;
      if (dims.length === 4) {
        aH = dims[2];
        aW = dims[3];
      } else if (dims.length === 3) {
        aH = dims[1];
        aW = dims[2];
      } else {
        aH = netH;
        aW = netW;
      }

      // Make an alpha canvas same as srcW/srcH, so we can composite onto original size
      const alphaCanvas = document.createElement("canvas");
      alphaCanvas.width = aW;
      alphaCanvas.height = aH;
      const alphaCtx = alphaCanvas.getContext("2d");
      const alphaImgData = alphaCtx.createImageData(aW, aH);
      const alphaPixels = alphaImgData.data;

      for (let i = 0; i < aW * aH; i++) {
        const a = Math.max(0, Math.min(1, alphaData[i])); // clamp
        const v = Math.round(a * 255);
        const j = i * 4;
        alphaPixels[j] = v;
        alphaPixels[j + 1] = v;
        alphaPixels[j + 2] = v;
        alphaPixels[j + 3] = 255;
      }

      alphaCtx.putImageData(alphaImgData, 0, 0);

      // Resize alpha matte back to original size
      const finalAlphaCanvas = document.createElement("canvas");
      finalAlphaCanvas.width = srcW;
      finalAlphaCanvas.height = srcH;
      const finalAlphaCtx = finalAlphaCanvas.getContext("2d");
      finalAlphaCtx.drawImage(alphaCanvas, 0, 0, srcW, srcH);
      const finalAlphaData = finalAlphaCtx.getImageData(0, 0, srcW, srcH).data;

      // Get original image again (source)
      const srcData = ctx.getImageData(0, 0, srcW, srcH);
      const srcPixels = srcData.data;

      // Composite: foreground * alpha + white * (1 - alpha)
      for (let i = 0; i < srcW * srcH; i++) {
        const j = i * 4;
        const a = finalAlphaData[j] / 255; // from 0..255 to 0..1
        const invA = 1 - a;

        const r = srcPixels[j];
        const g = srcPixels[j + 1];
        const b = srcPixels[j + 2];

        const outR = r * a + 255 * invA;
        const outG = g * a + 255 * invA;
        const outB = b * a + 255 * invA;

        srcPixels[j] = outR;
        srcPixels[j + 1] = outG;
        srcPixels[j + 2] = outB;
        srcPixels[j + 3] = 255;
      }

      ctx.putImageData(srcData, 0, 0);
      originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    // ===== 8. ENHANCEMENTS =====
    function resetSlidersOnly() {
      brightnessSlider.value = 0;
      contrastSlider.value = 0;
    }

    function resetToOriginal() {
      if (!hasImage || !originalImageData) return;
      canvas.width = originalWidth;
      canvas.height = originalHeight;
      ctx.putImageData(originalImageData, 0, 0);
      resetSlidersOnly();
      setStatus("Reset to AI-cleaned original (white background).", "ok");
    }

    function applyQuickEnhance() {
      if (!hasImage) {
        setStatus("No image to enhance.", "err");
        return;
      }
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      const brightnessOffset = 10;
      const contrastFactor = 1.07;
      for (let i = 0; i < data.length; i += 4) {
        for (let c = 0; c < 3; c++) {
          let v = data[i + c];
          v = v * contrastFactor + brightnessOffset;
          if (v < 0) v = 0;
          if (v > 255) v = 255;
          data[i + c] = v;
        }
      }
      ctx.putImageData(img, 0, 0);
      setStatus("Quick Enhance applied.", "ok");
    }

    function applyAdjustments() {
      if (!hasImage) {
        setStatus("No image to adjust.", "err");
        return;
      }
      const b = parseInt(brightnessSlider.value, 10) || 0;
      const c = parseInt(contrastSlider.value, 10) || 0;
      const brightnessOffset = b;
      const contrastFactor = 1 + c / 100;

      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      for (let i = 0; i < data.length; i += 4) {
        for (let ch = 0; ch < 3; ch++) {
          let v = data[i + ch];
          v = v * contrastFactor + brightnessOffset;
          if (v < 0) v = 0;
          if (v > 255) v = 255;
          data[i + ch] = v;
        }
      }
      ctx.putImageData(img, 0, 0);
      setStatus("Adjustments applied.", "ok");
    }

    // ===== 9. SIZE PRESET + EXPORT =====
    sizePreset.addEventListener("change", () => {
      customSizeRow.style.display = sizePreset.value === "custom" ? "flex" : "none";
    });

    function downloadFinal() {
      if (!hasImage) {
        setStatus("No image to download.", "err");
        return;
      }
      let targetW, targetH;
      switch (sizePreset.value) {
        case "passport":
          targetW = 413; targetH = 531; break;
        case "us2x2":
          targetW = 600; targetH = 600; break;
        case "inch1x1":
          targetW = 300; targetH = 300; break;
        case "custom":
          targetW = parseInt(customWidth.value, 10);
          targetH = parseInt(customHeight.value, 10);
          if (!targetW || !targetH || targetW <= 0 || targetH <= 0) {
            setStatus("Enter valid custom width/height.", "err");
            return;
          }
          break;
        case "original":
        default:
          targetW = canvas.width;
          targetH = canvas.height;
          break;
      }

      const out = document.createElement("canvas");
      out.width = targetW;
      out.height = targetH;
      const octx = out.getContext("2d");

      octx.fillStyle = "#ffffff";
      octx.fillRect(0, 0, targetW, targetH);

      const srcW = canvas.width;
      const srcH = canvas.height;
      const scale = Math.max(targetW / srcW, targetH / srcH);
      const drawW = srcW * scale;
      const drawH = srcH * scale;
      const dx = (targetW - drawW) / 2;
      const dy = (targetH - drawH) / 2;
      octx.drawImage(canvas, dx, dy, drawW, drawH);

      const dataURL = out.toDataURL("image/jpeg", 0.95);
      const link = document.createElement("a");
      link.href = dataURL;
      link.download = "id_photo_" + sizePreset.value + ".jpg";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      setStatus("JPEG downloaded. Save to Photos/Gallery and print at 300 dpi.", "ok");
    }

    // ===== 10. EVENT WIRING =====
    startCameraBtn.addEventListener("click", startCamera);
    captureBtn.addEventListener("click", capturePhoto);
    fileInput.addEventListener("change", handleFileUpload);

    quickEnhanceBtn.addEventListener("click", applyQuickEnhance);
    resetBtn.addEventListener("click", resetToOriginal);
    applyAdjustBtn.addEventListener("click", applyAdjustments);
    clearAdjustBtn.addEventListener("click", () => {
      resetSlidersOnly();
      setStatus("Sliders cleared.", "");
    });

    downloadBtn.addEventListener("click", downloadFinal);

    // Load MODNet from embedded Base64 on startup
    setStatus("Loading MODNet model from embedded Base64…", "");
    loadModNetModel();
  </script>
</body>
</html>