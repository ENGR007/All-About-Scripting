<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>My Notebook ‚Äì Live Recorder & Transcriber</title>
  <style>
    :root {
      --bg: #0b1120;
      --bg-alt: #111827;
      --panel: #020617;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.16);
      --accent-strong: #0ea5e9;
      --border: #1f2937;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --danger: #f97373;
      --success: #4ade80;
      --warning: #facc15;
      --radius-lg: 14px;
      --radius-md: 9px;
      --radius-pill: 999px;
      --shadow-soft: 0 18px 45px rgba(15,23,42,0.95);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
      background: radial-gradient(circle at top, #020617 0, #020617 30%, #000 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* HEADER */
    header {
      padding: 14px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid rgba(148,163,184,0.25);
      background: radial-gradient(circle at top left, #0b1120, #020617);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .logo-badge {
      width: 30px;
      height: 30px;
      border-radius: 10px;
      background: conic-gradient(from 180deg, #0ea5e9, #06b6d4, #22c55e, #a855f7, #0ea5e9);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 10px 30px rgba(8,47,73,0.7);
      font-size: 18px;
    }

    .logo-title {
      display: flex;
      flex-direction: column;
    }

    .logo-title span:first-child {
      font-weight: 600;
      letter-spacing: 0.04em;
      font-size: 14px;
      text-transform: uppercase;
      color: #e5e7eb;
    }

    .logo-title span:last-child {
      font-size: 12px;
      color: #9ca3af;
    }

    .header-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .chip {
      border-radius: 999px;
      padding: 4px 11px;
      font-size: 11px;
      background: rgba(15,23,42,0.85);
      border: 1px solid rgba(148,163,184,0.4);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: #cbd5f5;
    }

    .chip-dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: #22c55e;
      box-shadow: 0 0 12px #22c55e;
    }

    /* LAYOUT */
    .app-shell {
      display: grid;
      grid-template-columns: 290px minmax(0,1fr);
      gap: 14px;
      padding: 14px 16px 16px;
      flex: 1;
      overflow: hidden;
    }

    @media (max-width: 900px) {
      .app-shell {
        grid-template-columns: 1fr;
      }
    }

    /* LEFT: SESSIONS */
    .panel {
      background: radial-gradient(circle at top left, #020617, #020617 40%, #020617 100%);
      border-radius: 22px;
      border: 1px solid rgba(15,23,42,0.95);
      box-shadow: var(--shadow-soft);
      padding: 12px;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 4px 10px;
      border-bottom: 1px solid rgba(31,41,55,0.9);
      margin-bottom: 6px;
    }

    .panel-title {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.09em;
      color: #9ca3af;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .panel-title span.icon {
      font-size: 14px;
    }

    .panel-buttons {
      display: flex;
      gap: 6px;
    }

    button {
      border: none;
      cursor: pointer;
      border-radius: var(--radius-pill);
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(15,23,42,1);
      color: var(--muted);
      border: 1px solid rgba(55,65,81,0.9);
      transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease, transform 0.05s ease;
    }

    button:hover:not(:disabled) {
      background: rgba(15,23,42,0.85);
      border-color: var(--accent-strong);
      color: var(--accent-strong);
      transform: translateY(-0.5px);
    }

    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .btn-primary {
      background: radial-gradient(circle at top left, #0ea5e9, #0369a1);
      border-color: #0ea5e9;
      color: #0f172a;
    }

    .btn-primary:hover:not(:disabled) {
      background: radial-gradient(circle at top left, #38bdf8, #0284c7);
      border-color: #38bdf8;
    }

    .btn-danger {
      color: #fecaca;
      border-color: rgba(248,113,113,0.6);
      background: rgba(24,24,27,0.85);
    }

    .btn-danger:hover:not(:disabled) {
      background: rgba(127,29,29,0.85);
      border-color: #f87171;
      color: #fee2e2;
    }

    .btn-soft {
      background: rgba(15,23,42,0.9);
      border-color: rgba(51,65,85,0.9);
    }

    /* SESSION LIST */
    .session-list {
      margin: 0;
      padding: 0;
      list-style: none;
      overflow-y: auto;
      scrollbar-width: thin;
      max-height: calc(100vh - 170px);
    }

    .session-list::-webkit-scrollbar {
      width: 6px;
    }

    .session-list::-webkit-scrollbar-thumb {
      background: rgba(55,65,81,0.9);
      border-radius: 999px;
    }

    .session-item {
      border-radius: 14px;
      padding: 8px 9px;
      border: 1px solid rgba(31,41,55,0.9);
      background: radial-gradient(circle at top left, rgba(15,23,42,0.98), #020617);
      margin-bottom: 7px;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .session-item.active {
      border-color: var(--accent-strong);
      box-shadow: 0 0 0 1px rgba(56,189,248,0.25);
      background: radial-gradient(circle at top left, rgba(8,47,73,0.95), #020617);
    }

    .session-main-row {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .session-title-input {
      flex: 1;
      border-radius: 999px;
      border: 1px solid rgba(55,65,81,0.9);
      background: rgba(15,23,42,0.85);
      color: var(--text);
      font-size: 12px;
      padding: 5px 9px;
      outline: none;
    }

    .session-title-input:focus {
      border-color: var(--accent-strong);
    }

    .session-meta {
      font-size: 10px;
      color: #6b7280;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .session-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    /* RIGHT: EDITOR / RECORDER */
    .editor-panel {
      padding: 16px;
      border-radius: 22px;
      border: 1px solid rgba(15,23,42,0.95);
      background: radial-gradient(circle at top, rgba(15,23,42,0.98), #020617);
      box-shadow: var(--shadow-soft);
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .editor-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 14px;
      border-bottom: 1px solid rgba(31,41,55,0.9);
      padding-bottom: 8px;
      margin-bottom: 10px;
    }

    .editor-title-block {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .editor-title {
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #e5e7eb;
    }

    .editor-subtitle {
      font-size: 11px;
      color: #9ca3af;
    }

    .recording-status {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      padding: 4px 11px;
      font-size: 11px;
      background: rgba(23,23,23,0.8);
      border: 1px solid rgba(75,85,99,0.8);
    }

    .dot-recording {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #ef4444;
      box-shadow: 0 0 12px rgba(248,113,113,0.98);
    }

    .dot-idle {
      background: #4ade80;
      box-shadow: 0 0 8px rgba(74,222,128,0.95);
    }

    .editor-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      justify-content: flex-end;
    }

    .pill {
      border-radius: 999px;
      padding: 3px 10px;
      font-size: 10px;
      border: 1px solid rgba(55,65,81,0.9);
      color: #9ca3af;
      display: inline-flex;
      align-items: center;
      gap: 5px;
    }

    .pill-code {
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 10px;
      background: rgba(15,23,42,0.9);
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(51,65,85,0.9);
    }

    /* BODY */
    .editor-body {
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 1fr);
      gap: 12px;
      margin-top: 4px;
      min-height: 0;
    }

    @media (max-width: 1000px) {
      .editor-body {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: radial-gradient(circle at top, rgba(15,23,42,0.98), #020617);
      border-radius: 18px;
      border: 1px solid rgba(31,41,55,0.95);
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-height: 0;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 11px;
      color: #9ca3af;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .card-header span.icon {
      font-size: 14px;
      margin-right: 4px;
    }

    .badge {
      padding: 3px 8px;
      border-radius: 999px;
      font-size: 10px;
      background: rgba(15,23,42,0.85);
      border: 1px solid rgba(55,65,81,0.9);
      color: #9ca3af;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .badge-pill-strong {
      background: rgba(8,47,73,0.9);
      border-color: rgba(56,189,248,0.5);
      color: #bae6fd;
    }

    textarea {
      width: 100%;
      border-radius: 14px;
      border: 1px solid rgba(31,41,55,0.9);
      padding: 8px 9px;
      background: rgba(15,23,42,0.95);
      color: var(--text);
      font-size: 13px;
      resize: none;
      outline: none;
      min-height: 180px;
      scrollbar-width: thin;
    }

    textarea:focus {
      border-color: var(--accent-strong);
    }

    textarea::-webkit-scrollbar {
      width: 6px;
    }

    textarea::-webkit-scrollbar-thumb {
      background: rgba(55,65,81,0.9);
      border-radius: 999px;
    }

    .audio-preview-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 11px;
      color: #9ca3af;
      margin-top: 4px;
      flex-wrap: wrap;
    }

    audio {
      width: 100%;
      border-radius: 999px;
      background: #020617;
    }

    .timer-chip {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(55,65,81,0.9);
      background: rgba(15,23,42,0.9);
      font-size: 11px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .timer-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #22c55e;
    }

    .timer-dot.recording {
      background: #fb7185;
      box-shadow: 0 0 10px #fb7185;
    }

    .helper-text {
      font-size: 10px;
      color: #6b7280;
    }

    .card-footer-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 11px;
      color: #6b7280;
      margin-top: 4px;
      flex-wrap: wrap;
      gap: 6px;
    }
  </style>
</head>
<body>
<header>
  <div class="logo">
    <div class="logo-badge">‚ô™</div>
    <div class="logo-title">
      <span>My Notebook</span>
      <span>Live Recorder ¬∑ Transcriber ¬∑ IndexedDB</span>
    </div>
  </div>
  <div class="header-actions">
    <span class="chip">
      <span class="chip-dot"></span>
      Auto-saving to browser ¬∑ IndexedDB
    </span>
  </div>
</header>

<main class="app-shell">
  <!-- LEFT: SESSIONS -->
  <section class="panel" aria-label="Sessions">
    <div class="panel-header">
      <div class="panel-title">
        <span class="icon">üìí</span>
        <span>Sessions</span>
      </div>
      <div class="panel-buttons">
        <button id="btnNewSession" class="btn-soft" title="Start a fresh session">
          ‚ûï New
        </button>
        <button id="btnExportAll" class="btn-soft" title="Export all sessions to a backup file">
          ‚¨á Export All
        </button>
        <button id="btnImportAll" class="btn-soft" title="Import sessions from a backup file">
          ‚¨Ü Import
        </button>
        <input type="file" id="importFileInput" accept="application/json" style="display:none" />
      </div>
    </div>

    <ul id="sessionList" class="session-list"></ul>
  </section>

  <!-- RIGHT: EDITOR / RECORDER -->
  <section class="editor-panel" aria-label="Recorder and transcript">
    <div class="editor-header">
      <div class="editor-title-block">
        <div class="editor-title">Session Notebook</div>
        <div class="editor-subtitle" id="currentSessionSubtitle">
          Ready ‚Äì changes stay in this browser only.
        </div>
      </div>
      <div class="editor-controls">
        <div class="recording-status" id="recordingStatus">
          <span id="recordingDot" class="dot-recording dot-idle"></span>
          <span id="recordingStatusText">Idle ¬∑ mic off</span>
        </div>
        <button id="btnStart" class="btn-primary">
          ‚è∫ Start Recording
        </button>
        <button id="btnStop" class="btn-danger" disabled>
          ‚èπ Stop
        </button>
        <button id="btnSaveSession" class="btn-soft">
          üíæ Save Session
        </button>
      </div>
    </div>

    <div class="editor-body">
      <!-- TRANSCRIPT -->
      <div class="card">
        <div class="card-header">
          <span><span class="icon">üìù</span>Live Transcript</span>
          <span class="badge badge-pill-strong">
            <span>üéô</span> Mic ‚Üí Text
          </span>
        </div>
        <textarea id="transcriptArea" placeholder="Live transcript will appear here as you speak..."></textarea>
        <div class="card-footer-row">
          <span class="helper-text">
            Tip: you can edit this text before saving the session.
          </span>
          <span id="wordCount" class="helper-text">
            0 characters
          </span>
        </div>
      </div>

      <!-- AUDIO PREVIEW & META -->
      <div class="card">
        <div class="card-header">
          <span><span class="icon">üéß</span>Recording</span>
          <span class="badge">
            <span>Storage:</span> IndexedDB
          </span>
        </div>

        <label class="helper-text" for="sessionTitleInput">Session title</label>
        <input
          id="sessionTitleInput"
          class="session-title-input"
          type="text"
          placeholder="Session title (leave empty to use date/time)"
        />

        <div style="margin-top:8px; font-size:11px; color:#9ca3af;">
          Current audio preview
        </div>

        <audio id="audioPreview" controls preload="metadata"></audio>

        <div class="audio-preview-row">
          <div class="timer-chip">
            <span id="timerDot" class="timer-dot"></span>
            <span id="recordingTimerText">00:00</span>
          </div>
          <span id="audioInfo" class="helper-text">
            No recording yet.
          </span>
        </div>

        <div class="card-footer-row">
          <div class="session-actions">
            <button id="btnDownloadAudio" class="btn-soft" disabled>‚¨á Audio</button>
            <button id="btnDownloadText" class="btn-soft" disabled>‚¨á Transcript</button>
          </div>
          <span class="helper-text">
            Long recordings are saved as a single file when you stop.
          </span>
        </div>
      </div>
    </div>
  </section>
</main>

<script>
  // ------------------------------
  // IndexedDB Setup
  // ------------------------------
  const DB_NAME = 'my_notebook_recorder_db_v2';
  const DB_VERSION = 1;
  const STORE_NAME = 'sessions';

  let db = null;

  function openDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION);

      request.onupgradeneeded = (event) => {
        const database = event.target.result;
        if (!database.objectStoreNames.contains(STORE_NAME)) {
          const store = database.createObjectStore(STORE_NAME, {
            keyPath: 'id',
            autoIncrement: true,
          });
          store.createIndex('createdAt', 'createdAt', { unique: false });
        }
      };

      request.onsuccess = () => {
        db = request.result;
        resolve(db);
      };

      request.onerror = () => {
        console.error('IndexedDB open error:', request.error);
        reject(request.error);
      };
    });
  }

  function saveSessionToDB(session) {
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);
      const request = store.put(session); // put = add or update

      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  function getSessionFromDB(id) {
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readonly');
      const store = tx.objectStore(STORE_NAME);
      const request = store.get(id);

      request.onsuccess = () => resolve(request.result || null);
      request.onerror = () => reject(request.error);
    });
  }

  function getAllSessionsFromDB() {
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readonly');
      const store = tx.objectStore(STORE_NAME);
      const request = store.getAll();

      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  // ------------------------------
  // Global State
  // ------------------------------
  let currentSessionId = null;
  let mediaRecorder = null;
  let recordedChunks = [];
  let currentAudioBlob = null;
  let isRecording = false;

  let recordingStartTime = null;
  let recordingTimerInterval = null;

  let recognition = null;
  let isRecognizing = false;

  let currentPlayback = {
    audio: null,
    button: null,
    url: null,
    sessionId: null,
  };

  // ------------------------------
  // DOM Elements
  // ------------------------------
  const sessionListEl = document.getElementById('sessionList');
  const btnNewSession = document.getElementById('btnNewSession');
  const btnExportAll = document.getElementById('btnExportAll');
  const btnImportAll = document.getElementById('btnImportAll');
  const importFileInput = document.getElementById('importFileInput');

  const btnStart = document.getElementById('btnStart');
  const btnStop = document.getElementById('btnStop');
  const btnSaveSession = document.getElementById('btnSaveSession');
  const btnDownloadAudio = document.getElementById('btnDownloadAudio');
  const btnDownloadText = document.getElementById('btnDownloadText');

  const transcriptArea = document.getElementById('transcriptArea');
  const wordCountEl = document.getElementById('wordCount');
  const sessionTitleInput = document.getElementById('sessionTitleInput');

  const recordingStatus = document.getElementById('recordingStatus');
  const recordingDot = document.getElementById('recordingDot');
  const recordingStatusText = document.getElementById('recordingStatusText');
  const currentSessionSubtitle = document.getElementById('currentSessionSubtitle');

  const audioPreview = document.getElementById('audioPreview');
  const audioInfo = document.getElementById('audioInfo');
  const timerDot = document.getElementById('timerDot');
  const recordingTimerText = document.getElementById('recordingTimerText');

  // ------------------------------
  // Utility
  // ------------------------------
  function formatDateTime(ts) {
    if (!ts) return '';
    const d = new Date(ts);
    return (
      d.getFullYear() +
      '-' +
      String(d.getMonth() + 1).padStart(2, '0') +
      '-' +
      String(d.getDate()).padStart(2, '0') +
      ' ' +
      String(d.getHours()).padStart(2, '0') +
      ':' +
      String(d.getMinutes()).padStart(2, '0')
    );
  }

  function formatDuration(seconds) {
    const s = Math.floor(seconds);
    const h = Math.floor(s / 3600);
    const m = Math.floor((s % 3600) / 60);
    const sec = s % 60;
    if (h > 0) {
      return (
        String(h).padStart(2, '0') +
        ':' +
        String(m).padStart(2, '0') +
        ':' +
        String(sec).padStart(2, '0')
      );
    }
    return String(m).padStart(2, '0') + ':' + String(sec).padStart(2, '0');
  }

  function updateWordCount() {
    const text = transcriptArea.value || '';
    wordCountEl.textContent = text.length + ' characters';
  }

  function setRecordingUI(recording) {
    isRecording = recording;
    btnStart.disabled = recording;
    btnStop.disabled = !recording;

    if (recording) {
      recordingDot.classList.remove('dot-idle');
      recordingDot.style.backgroundColor = '#ef4444';
      recordingDot.style.boxShadow = '0 0 12px rgba(248,113,113,0.98)';
      recordingStatusText.textContent = 'Recording‚Ä¶ mic on';
      timerDot.classList.add('recording');
    } else {
      recordingDot.classList.add('dot-idle');
      recordingDot.style.backgroundColor = '#4ade80';
      recordingDot.style.boxShadow = '0 0 8px rgba(74,222,128,0.95)';
      recordingStatusText.textContent = 'Idle ¬∑ mic off';
      timerDot.classList.remove('recording');
    }
  }

  function resetTimer() {
    recordingStartTime = null;
    if (recordingTimerInterval) {
      clearInterval(recordingTimerInterval);
      recordingTimerInterval = null;
    }
    recordingTimerText.textContent = '00:00';
  }

  function startTimer() {
    recordingStartTime = Date.now();
    if (recordingTimerInterval) clearInterval(recordingTimerInterval);
    recordingTimerInterval = setInterval(() => {
      if (!recordingStartTime) return;
      const elapsed = (Date.now() - recordingStartTime) / 1000;
      recordingTimerText.textContent = formatDuration(elapsed);
    }, 500);
  }

  function setAudioPreview(blob) {
    currentAudioBlob = blob;
    if (audioPreview.src) {
      URL.revokeObjectURL(audioPreview.src);
      audioPreview.removeAttribute('src');
    }
    if (blob) {
      const url = URL.createObjectURL(blob);
      audioPreview.src = url;
      audioInfo.textContent = 'Ready to play. This is the last full recording you saved.';
      btnDownloadAudio.disabled = false;
    } else {
      audioInfo.textContent = 'No recording yet.';
      btnDownloadAudio.disabled = true;
    }
  }

  function ensurePlaybackStopped() {
    if (currentPlayback.audio) {
      currentPlayback.audio.pause();
      currentPlayback.audio.currentTime = 0;
      if (currentPlayback.button) currentPlayback.button.textContent = 'Play';
      if (currentPlayback.url) URL.revokeObjectURL(currentPlayback.url);
      currentPlayback = { audio: null, button: null, url: null, sessionId: null };
    }
  }

  // ------------------------------
  // Speech Recognition (Web Speech API)
  // ------------------------------
  function setupSpeechRecognition() {
    const SpeechRecognition =
      window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      console.warn('Web Speech API not available.');
      currentSessionSubtitle.textContent =
        'Live transcript requires Chrome / Edge with mic permission.';
      return;
    }

    recognition = new SpeechRecognition();
    recognition.continuous = true;
    recognition.interimResults = true;
    recognition.lang = 'en-US';

    recognition.onresult = (event) => {
      let finalTranscript = transcriptArea.value || '';
      let interim = '';

      for (let i = event.resultIndex; i < event.results.length; i++) {
        const result = event.results[i];
        const text = result[0].transcript;
        if (result.isFinal) {
          finalTranscript += (finalTranscript.endsWith(' ') ? '' : ' ') + text.trim() + ' ';
        } else {
          interim += text;
        }
      }

      transcriptArea.value = finalTranscript + (interim ? '\n' + interim : '');
      updateWordCount();
    };

    recognition.onerror = (event) => {
      console.error('Speech recognition error:', event.error);
      if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
        currentSessionSubtitle.textContent =
          'Mic permission / speech service blocked. Check browser settings.';
      }
    };

    recognition.onend = () => {
      isRecognizing = false;
      // For long sessions, auto-restart if we are still recording
      if (isRecording) {
        try {
          recognition.start();
          isRecognizing = true;
        } catch (e) {
          console.error('Failed to restart recognition:', e);
        }
      }
    };
  }

  function startRecognition() {
    if (!recognition) return;
    try {
      recognition.start();
      isRecognizing = true;
    } catch (e) {
      console.error('Speech recognition start error:', e);
    }
  }

  function stopRecognition() {
    if (!recognition) return;
    try {
      recognition.stop();
    } catch (e) {
      console.error('Speech recognition stop error:', e);
    }
    isRecognizing = false;
  }

  // ------------------------------
  // Recording (MediaRecorder)
  // ------------------------------
  async function startRecording() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      recordedChunks = [];
      mediaRecorder = new MediaRecorder(stream);

      mediaRecorder.ondataavailable = (event) => {
        if (event.data && event.data.size > 0) {
          recordedChunks.push(event.data);
        }
      };

      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'audio/webm' });
        setAudioPreview(blob);
        const durationSeconds =
          recordingStartTime ? (Date.now() - recordingStartTime) / 1000 : 0;
        audioInfo.textContent =
          'Saved recording (' + formatDuration(durationSeconds) + ').';
        // Stop all tracks to release mic
        stream.getTracks().forEach((t) => t.stop());
        resetTimer();
      };

      mediaRecorder.start(1000); // timeslice to avoid memory spikes; unlimited duration
      setRecordingUI(true);
      startTimer();

      // Start speech recognition separately
      startRecognition();

      currentSessionSubtitle.textContent =
        'Recording‚Ä¶ audio & live transcript. Stop before saving the session.';
    } catch (err) {
      console.error('Error starting recording:', err);
      currentSessionSubtitle.textContent =
        'Unable to access microphone. Check browser permissions.';
      setRecordingUI(false);
      resetTimer();
    }
  }

  function stopRecording() {
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
      mediaRecorder.stop();
    }
    setRecordingUI(false);
    stopRecognition();
    currentSessionSubtitle.textContent =
      'Recording stopped. You can review audio and transcript, then save session.';
  }

  // ------------------------------
  // Session Handling
  // ------------------------------
  function getSessionTitleForSave() {
    const t = sessionTitleInput.value.trim();
    if (t) return t;
    // default: date/time string
    const now = new Date();
    return (
      'Session ' +
      now.getFullYear() +
      '-' +
      String(now.getMonth() + 1).padStart(2, '0') +
      '-' +
      String(now.getDate()).padStart(2, '0') +
      ' ' +
      String(now.getHours()).padStart(2, '0') +
      ':' +
      String(now.getMinutes()).padStart(2, '0')
    );
  }

  async function saveCurrentSession() {
    if (!db) {
      console.error('DB not ready');
      return;
    }

    const title = getSessionTitleForSave();
    const transcript = transcriptArea.value || '';
    const now = Date.now();

    let existing = null;
    if (currentSessionId != null) {
      existing = await getSessionFromDB(currentSessionId);
    }

    const sessionToSave = {
      id: existing ? existing.id : undefined, // let autoIncrement assign if new
      title,
      transcript,
      audioBlob: currentAudioBlob || (existing ? existing.audioBlob : null),
      createdAt: existing ? existing.createdAt : now,
      updatedAt: now,
    };

    const id = await saveSessionToDB(sessionToSave);
    currentSessionId = id;

    currentSessionSubtitle.textContent =
      'Saved ¬∑ ' + formatDateTime(now) + ' ¬∑ ID ' + id;
    renderSessionList();
  }

  async function renderSessionList() {
    if (!db) return;
    const sessions = await getAllSessionsFromDB();
    // sort newest first
    sessions.sort((a, b) => (b.updatedAt || b.createdAt) - (a.updatedAt || a.createdAt));

    sessionListEl.innerHTML = '';
    sessions.forEach((s) => {
      const li = document.createElement('li');
      li.className = 'session-item' + (s.id === currentSessionId ? ' active' : '');
      li.dataset.id = s.id;

      const mainRow = document.createElement('div');
      mainRow.className = 'session-main-row';

      const titleInput = document.createElement('input');
      titleInput.type = 'text';
      titleInput.value = s.title || '';
      titleInput.className = 'session-title-input';
      titleInput.addEventListener('change', async () => {
        const updated = await getSessionFromDB(s.id);
        if (!updated) return;
        updated.title = titleInput.value.trim() || updated.title;
        updated.updatedAt = Date.now();
        await saveSessionToDB(updated);
        renderSessionList();
      });

      const btnOpen = document.createElement('button');
      btnOpen.className = 'btn-soft';
      btnOpen.textContent = 'Open';
      btnOpen.addEventListener('click', () => loadSession(s.id));

      mainRow.appendChild(titleInput);
      mainRow.appendChild(btnOpen);

      const metaRow = document.createElement('div');
      metaRow.className = 'session-meta';
      const dateSpan = document.createElement('span');
      dateSpan.textContent =
        'Updated ' +
        formatDateTime(s.updatedAt || s.createdAt) +
        (s.audioBlob ? ' ¬∑ üéß' : '');
      const idSpan = document.createElement('span');
      idSpan.textContent = '#' + s.id;
      metaRow.appendChild(dateSpan);
      metaRow.appendChild(idSpan);

      const actionRow = document.createElement('div');
      actionRow.className = 'session-actions';

      const playBtn = document.createElement('button');
      playBtn.className = 'btn-soft';
      playBtn.textContent = 'Play';
      playBtn.disabled = !s.audioBlob;
      playBtn.addEventListener('click', (e) => {
        playSessionAudio(s.id, playBtn);
      });

      const dlAudioBtn = document.createElement('button');
      dlAudioBtn.className = 'btn-soft';
      dlAudioBtn.textContent = '‚¨á Audio';
      dlAudioBtn.disabled = !s.audioBlob;
      dlAudioBtn.addEventListener('click', () => downloadSessionAudio(s));

      const dlTextBtn = document.createElement('button');
      dlTextBtn.className = 'btn-soft';
      dlTextBtn.textContent = '‚¨á Text';
      dlTextBtn.addEventListener('click', () => downloadSessionText(s));

      actionRow.appendChild(playBtn);
      actionRow.appendChild(dlAudioBtn);
      actionRow.appendChild(dlTextBtn);

      li.appendChild(mainRow);
      li.appendChild(metaRow);
      li.appendChild(actionRow);

      sessionListEl.appendChild(li);
    });
  }

  async function loadSession(id) {
    const s = await getSessionFromDB(id);
    if (!s) return;

    currentSessionId = s.id;
    sessionTitleInput.value = s.title || '';
    transcriptArea.value = s.transcript || '';
    updateWordCount();

    setAudioPreview(s.audioBlob || null);

    if (s.audioBlob) {
      audioInfo.textContent =
        'Loaded saved recording. Press play here or on the session item.';
      btnDownloadAudio.disabled = false;
    } else {
      audioInfo.textContent = 'No audio stored for this session.';
      btnDownloadAudio.disabled = true;
    }

    btnDownloadText.disabled = !(s.transcript && s.transcript.length);
    currentSessionSubtitle.textContent =
      'Loaded session #' + s.id + ' ¬∑ ' + (s.title || '');
    renderSessionList();
  }

  function newSession() {
    ensurePlaybackStopped();
    currentSessionId = null;
    sessionTitleInput.value = '';
    transcriptArea.value = '';
    updateWordCount();
    setAudioPreview(null);
    btnDownloadText.disabled = true;
    btnDownloadAudio.disabled = true;
    currentSessionSubtitle.textContent = 'New session ¬∑ not yet saved.';
    renderSessionList();
  }

  // ------------------------------
  // Play / Download
  // ------------------------------
  async function playSessionAudio(id, button) {
    // If same session is currently playing, stop it
    if (currentPlayback.audio && currentPlayback.sessionId === id && !currentPlayback.audio.paused) {
      currentPlayback.audio.pause();
      currentPlayback.audio.currentTime = 0;
      if (currentPlayback.button) currentPlayback.button.textContent = 'Play';
      if (currentPlayback.url) URL.revokeObjectURL(currentPlayback.url);
      currentPlayback = { audio: null, button: null, url: null, sessionId: null };
      return;
    }

    // Stop any other session currently playing
    if (currentPlayback.audio && !currentPlayback.audio.paused) {
      currentPlayback.audio.pause();
      currentPlayback.audio.currentTime = 0;
      if (currentPlayback.button) currentPlayback.button.textContent = 'Play';
      if (currentPlayback.url) URL.revokeObjectURL(currentPlayback.url);
      currentPlayback = { audio: null, button: null, url: null, sessionId: null };
    }

    const s = await getSessionFromDB(id);
    if (!s || !s.audioBlob) return;

    const url = URL.createObjectURL(s.audioBlob);
    const audio = new Audio(url);

    currentPlayback = {
      audio,
      button,
      url,
      sessionId: id,
    };

    button.textContent = 'Stop';

    audio.play().catch((err) => {
      console.error('Play error:', err);
      button.textContent = 'Play';
      URL.revokeObjectURL(url);
      currentPlayback = { audio: null, button: null, url: null, sessionId: null };
    });

    audio.onended = () => {
      if (currentPlayback.button) currentPlayback.button.textContent = 'Play';
      if (currentPlayback.url) URL.revokeObjectURL(currentPlayback.url);
      currentPlayback = { audio: null, button: null, url: null, sessionId: null };
    };
  }

  function downloadBlob(blob, filename) {
    if (!blob) return;
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function downloadSessionAudio(session) {
    if (!session.audioBlob) return;
    const safeTitle = (session.title || 'session').replace(/[\\/:*?"<>|]/g, '_');
    downloadBlob(session.audioBlob, safeTitle + '.webm');
  }

  function downloadSessionText(session) {
    const text = session.transcript || '';
    const safeTitle = (session.title || 'session').replace(/[\\/:*?"<>|]/g, '_');
    const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
    downloadBlob(blob, safeTitle + '.txt');
  }

  // Current session download buttons on right panel
  btnDownloadAudio.addEventListener('click', () => {
    if (!currentAudioBlob) return;
    const safeTitle = getSessionTitleForSave().replace(/[\\/:*?"<>|]/g, '_');
    downloadBlob(currentAudioBlob, safeTitle + '.webm');
  });

  btnDownloadText.addEventListener('click', () => {
    const text = transcriptArea.value || '';
    if (!text) return;
    const safeTitle = getSessionTitleForSave().replace(/[\\/:*?"<>|]/g, '_');
    const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
    downloadBlob(blob, safeTitle + '.txt');
  });

  // ------------------------------
  // Export / Import (backup)
  // ------------------------------
  function blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      if (!blob) return resolve(null);
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob); // data: URL
    });
  }

  function base64ToBlob(dataUrl) {
    if (!dataUrl) return null;
    const parts = dataUrl.split(',');
    const mime = parts[0].match(/:(.*?);/)[1];
    const bstring = atob(parts[1]);
    const n = bstring.length;
    const u8 = new Uint8Array(n);
    for (let i = 0; i < n; i++) {
      u8[i] = bstring.charCodeAt(i);
    }
    return new Blob([u8], { type: mime });
  }

  async function exportAllSessions() {
    const sessions = await getAllSessionsFromDB();
    const exportPayload = [];

    for (const s of sessions) {
      const audioBase64 = await blobToBase64(s.audioBlob || null);
      exportPayload.push({
        id: s.id,
        title: s.title,
        transcript: s.transcript,
        audioBase64,
        createdAt: s.createdAt,
        updatedAt: s.updatedAt,
      });
    }

    const blob = new Blob([JSON.stringify(exportPayload)], {
      type: 'application/json;charset=utf-8',
    });

    const now = new Date();
    const fileName =
      'my_notebook_backup_' +
      now.getFullYear() +
      String(now.getMonth() + 1).padStart(2, '0') +
      String(now.getDate()).padStart(2, '0') +
      '_' +
      String(now.getHours()).padStart(2, '0') +
      String(now.getMinutes()).padStart(2, '0') +
      '.json';

    downloadBlob(blob, fileName);
  }

  async function importAllSessionsFromFile(file) {
    const text = await file.text();
    const data = JSON.parse(text);
    if (!Array.isArray(data)) return;

    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);

    for (const item of data) {
      const session = {
        id: undefined, // let DB assign new IDs to avoid collision
        title: item.title,
        transcript: item.transcript,
        audioBlob: base64ToBlob(item.audioBase64 || null),
        createdAt: item.createdAt || Date.now(),
        updatedAt: item.updatedAt || item.createdAt || Date.now(),
      };
      store.add(session);
    }

    await new Promise((resolve, reject) => {
      tx.oncomplete = resolve;
      tx.onerror = () => reject(tx.error);
    });

    renderSessionList();
  }

  // ------------------------------
  // Event Listeners
  // ------------------------------
  btnStart.addEventListener('click', () => {
    ensurePlaybackStopped();
    startRecording();
  });

  btnStop.addEventListener('click', () => {
    stopRecording();
  });

  btnSaveSession.addEventListener('click', async () => {
    await saveCurrentSession();
    btnDownloadText.disabled = !(transcriptArea.value && transcriptArea.value.length);
  });

  btnNewSession.addEventListener('click', () => {
    newSession();
  });

  transcriptArea.addEventListener('input', updateWordCount);

  btnExportAll.addEventListener('click', () => {
    exportAllSessions();
  });

  btnImportAll.addEventListener('click', () => {
    importFileInput.value = '';
    importFileInput.click();
  });

  importFileInput.addEventListener('change', async (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    try {
      await importAllSessionsFromFile(file);
      currentSessionSubtitle.textContent = 'Import complete.';
    } catch (err) {
      console.error('Import error:', err);
      currentSessionSubtitle.textContent = 'Import failed. Check console for details.';
    }
  });

  // ------------------------------
  // Init
  // ------------------------------
  (async function init() {
    try {
      await openDB();
      setupSpeechRecognition();
      await renderSessionList();
      updateWordCount();
      currentSessionSubtitle.textContent =
        'Ready ¬∑ use Start Recording for live mic & transcript, then Save Session.';
    } catch (err) {
      console.error('Init error:', err);
      currentSessionSubtitle.textContent =
        'Error initialising local storage. Check console for details.';
    }
  })();
</script>
</body>
</html>
