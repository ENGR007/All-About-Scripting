<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Live Recorder & Transcriber Notebook</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #0b1020;
      --card-bg: #141b2f;
      --accent: #ffb84d;
      --accent-soft: rgba(255, 184, 77, 0.15);
      --accent-strong: #ff9f1c;
      --border: #26324d;
      --text: #f5f7ff;
      --text-soft: #a7b3d9;
      --danger: #ff4d6a;
      --success: #5bd38a;
      --muted-chip: #1f2942;
      --scroll-thumb: #36456a;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1d2642 0, #050814 55%, #020309 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }

    .app-shell {
      width: 100%;
      max-width: 1080px;
      margin: 24px;
      background: linear-gradient(145deg, rgba(10, 14, 31, 0.95), rgba(7, 9, 20, 0.98));
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      box-shadow:
        0 30px 60px rgba(0, 0, 0, 0.8),
        0 0 0 1px rgba(255, 255, 255, 0.02);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      backdrop-filter: blur(20px);
    }

    .app-header {
      padding: 18px 22px 14px 22px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      background: radial-gradient(circle at left, rgba(255, 184, 77, 0.13), transparent 60%);
    }

    .app-title-area {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .app-title {
      font-size: 20px;
      font-weight: 650;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .title-pill {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(4, 9, 24, 0.8);
      text-transform: none;
      letter-spacing: 0.02em;
      color: var(--text-soft);
    }

    .app-subtitle {
      font-size: 12px;
      color: var(--text-soft);
    }

    .app-badge {
      padding: 4px 10px;
      border-radius: 999px;
      background: var(--accent-soft);
      color: var(--accent-strong);
      font-size: 11px;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid rgba(255, 184, 77, 0.4);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .app-body {
      display: grid;
      grid-template-columns: minmax(0, 2.3fr) minmax(0, 2fr);
      gap: 16px;
      padding: 16px 18px 20px 18px;
    }

    @media (max-width: 900px) {
      .app-body {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .card {
      background: var(--card-bg);
      border-radius: 16px;
      padding: 14px 14px 12px 14px;
      border: 1px solid var(--border);
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.45);
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 0;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 8px;
    }

    .card-title {
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: var(--text);
    }

    .card-subtitle {
      font-size: 11px;
      color: var(--text-soft);
    }

    .chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 2px;
    }

    .chip {
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 10px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: var(--muted-chip);
      color: var(--text-soft);
    }

    .chip.live {
      border-color: rgba(255, 77, 106, 0.8);
      color: var(--danger);
      background: rgba(255, 77, 106, 0.1);
    }

    .chip.ok {
      border-color: rgba(91, 211, 138, 0.7);
      color: var(--success);
      background: rgba(91, 211, 138, 0.08);
    }

    .field-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 4px;
    }

    label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      color: var(--text-soft);
    }

    input[type="text"] {
      background: #0b1020;
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: 6px 9px;
      font-size: 13px;
      color: var(--text);
      outline: none;
    }

    input[type="text"]:focus {
      border-color: var(--accent-strong);
      box-shadow: 0 0 0 1px rgba(255, 184, 77, 0.5);
    }

    textarea {
      width: 100%;
      resize: vertical;
      min-height: 140px;
      max-height: 260px;
      background: #050814;
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 10px;
      font-size: 13px;
      color: var(--text);
      line-height: 1.4;
      outline: none;
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    textarea:focus {
      border-color: var(--accent-strong);
      box-shadow: 0 0 0 1px rgba(255, 184, 77, 0.5);
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    button {
      border-radius: 999px;
      border: 1px solid transparent;
      padding: 7px 14px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      background: var(--muted-chip);
      color: var(--text);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: transform 0.04s ease-out, box-shadow 0.1s ease-out, background 0.15s, border-color 0.15s;
    }

    button:disabled {
      opacity: 0.35;
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.5);
    }

    .btn-primary {
      background: var(--accent-strong);
      color: #15100a;
      border-color: rgba(255, 184, 77, 0.9);
    }

    .btn-danger {
      background: rgba(255, 77, 106, 0.2);
      border-color: rgba(255, 77, 106, 0.7);
      color: var(--danger);
    }

    .btn-ghost {
      background: transparent;
      border-color: var(--border);
      color: var(--text-soft);
    }

    .status-text {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: var(--scroll-thumb);
    }

    .dot.live {
      background: var(--danger);
      box-shadow: 0 0 0 4px rgba(255, 77, 106, 0.3);
    }

    .dot.idle {
      background: var(--scroll-thumb);
    }

    .sessions-list {
      overflow-y: auto;
      max-height: 370px;
      padding-right: 4px;
    }

    .sessions-list::-webkit-scrollbar {
      width: 6px;
    }

    .sessions-list::-webkit-scrollbar-thumb {
      background: var(--scroll-thumb);
      border-radius: 999px;
    }

    .session-card {
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 10px 10px 8px 10px;
      background: rgba(5, 9, 24, 0.95);
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 8px;
    }

    .session-header-row {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      align-items: center;
    }

    .session-name-input {
      flex: 1;
    }

    .session-meta {
      font-size: 11px;
      color: var(--text-soft);
    }

    .session-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 4px;
    }

    audio {
      width: 100%;
      margin-top: 4px;
    }

    .badge-pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 7px;
      border-radius: 999px;
      font-size: 10px;
      background: rgba(255, 184, 77, 0.12);
      color: var(--accent);
      border: 1px solid rgba(255, 184, 77, 0.4);
    }

    .backup-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-top: 2px;
    }

    input[type="file"] {
      font-size: 11px;
      color: var(--text-soft);
    }

    .hint {
      font-size: 10px;
      color: var(--text-soft);
      opacity: 0.9;
    }

    .pill-counter {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.06);
      color: var(--text-soft);
    }
  </style>
</head>
<body>
<div class="app-shell">
  <header class="app-header">
    <div class="app-title-area">
      <div class="app-title">
        LIVE NOTEBOOK
        <span class="title-pill">Recorder + Transcriber</span>
      </div>
      <div class="app-subtitle">
        Record high-quality audio, see live text, save sessions, and export/import everything locally.
      </div>
    </div>
    <div class="app-badge">
      ‚óè Live
      <span>Browser-only, no server</span>
    </div>
  </header>

  <main class="app-body">
    <!-- LEFT: Live Recorder / Transcriber -->
    <section class="card">
      <div class="card-header">
        <div>
          <div class="card-title">Live Capture</div>
          <div class="card-subtitle">Microphone recording + live speech-to-text</div>
        </div>
        <div class="chip-row">
          <span id="speechSupportChip" class="chip">Speech API: checking‚Ä¶</span>
          <span id="audioSupportChip" class="chip">Audio: checking‚Ä¶</span>
        </div>
      </div>

      <div class="field-group">
        <label for="sessionName">Session name</label>
        <input
          type="text"
          id="sessionName"
          placeholder="Optional ‚Äî leave empty to use date/time as name"
        />
        <span class="hint">
          If left blank, name will be e.g. <strong>Session_2025-11-24_18-30-05</strong>
        </span>
      </div>

      <div class="field-group">
        <label>Controls</label>
        <div class="row">
          <button id="startBtn" class="btn-primary">
            ‚ñ∂ Start recording + transcription
          </button>
          <button id="stopBtn" class="btn-danger" disabled>
            ‚ñ† Stop
          </button>
          <button id="saveSessionBtn" class="btn-ghost" disabled>
            üíæ Save session
          </button>
        </div>
        <div class="status-text">
          <span id="statusDot" class="dot idle"></span>
          <span id="statusText">Idle. Click ‚ÄúStart‚Äù to begin.</span>
        </div>
      </div>

      <div class="field-group">
        <label for="transcriptArea">Live transcript</label>
        <textarea
          id="transcriptArea"
          placeholder="Transcript will appear here while you speak‚Ä¶"
        ></textarea>
        <span class="hint">
          Live partial text appears at the bottom; final text is kept when phrases finish.
        </span>
      </div>

      <div class="field-group">
        <label>Current audio preview</label>
        <audio id="currentAudio" controls></audio>
        <div class="status-text">
          <span id="recordingTimerText">Recording duration: 00:00</span>
        </div>
        <span class="hint">
          After you click <strong>Stop</strong>, the latest recording appears here. Then click
          <strong>Save session</strong> to store audio + text in the notebook.
        </span>
      </div>
    </section>

    <!-- RIGHT: Saved Sessions / Backup -->
    <section class="card">
      <div class="card-header">
        <div>
          <div class="card-title">Session Notebook</div>
          <div class="card-subtitle">Saved recordings & transcripts in this browser</div>
        </div>
        <div class="chip-row">
          <span id="sessionCount" class="pill-counter">0 sessions</span>
        </div>
      </div>

      <div class="field-group">
        <label>Backup & restore</label>
        <div class="backup-row">
          <button id="exportBtn" class="btn-ghost">
            ‚¨á Export all (JSON)
          </button>
          <button id="clearAllBtn" class="btn-danger">
            üóë Clear all
          </button>
          <input id="importFile" type="file" accept="application/json" />
        </div>
        <span class="hint">
          Export to keep a backup (.json). Import later (or on another browser) to restore sessions.
        </span>
      </div>

      <div class="field-group">
        <label>Saved sessions</label>
        <div id="sessionsList" class="sessions-list">
          <!-- Sessions injected here -->
        </div>
        <span class="hint">
          All data is stored locally in your browser (IndexedDB). For very long recordings,
          it‚Äôs still good practice to download the audio & transcript to your drive.
        </span>
      </div>
    </section>
  </main>
</div>

<script>
  // ---------------------------
  // Feature detection & globals
  // ---------------------------

  const SpeechRecognition =
    window.SpeechRecognition || window.webkitSpeechRecognition || null;
  const speechSupportChip = document.getElementById("speechSupportChip");
  const audioSupportChip = document.getElementById("audioSupportChip");

  if (!SpeechRecognition) {
    speechSupportChip.textContent = "Speech API: not supported";
    speechSupportChip.classList.add("chip");
  } else {
    speechSupportChip.textContent = "Speech API: OK";
    speechSupportChip.classList.add("chip", "ok");
  }

  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    audioSupportChip.textContent = "Audio: not supported";
  } else {
    audioSupportChip.textContent = "Audio: OK";
    audioSupportChip.classList.add("chip", "ok");
  }

  const startBtn = document.getElementById("startBtn");
  const stopBtn = document.getElementById("stopBtn");
  const saveSessionBtn = document.getElementById("saveSessionBtn");
  const statusText = document.getElementById("statusText");
  const statusDot = document.getElementById("statusDot");
  const transcriptArea = document.getElementById("transcriptArea");
  const sessionNameInput = document.getElementById("sessionName");
  const currentAudio = document.getElementById("currentAudio");
  const sessionsList = document.getElementById("sessionsList");
  const sessionCount = document.getElementById("sessionCount");
  const exportBtn = document.getElementById("exportBtn");
  const clearAllBtn = document.getElementById("clearAllBtn");
  const importFileInput = document.getElementById("importFile");
  const recordingTimerText = document.getElementById("recordingTimerText");

  let recognition = null;
  let recognizing = false;
  let finalTranscript = "";
  let interimTranscript = "";

  let mediaRecorder = null;
  let recordedChunks = [];
  let currentAudioBlob = null;

  // Timer state
  let recordingStartTime = null;
  let recordingTimerInterval = null;

  // Playback state for saved sessions
  let playButtonsBySession = {};
  let currentPlayingSessionId = null;
  let currentAudioUrl = null;

  // IndexedDB constants
  const DB_NAME = "LiveNotebookDB";
  const DB_VERSION = 1;
  const STORE_NAME = "sessions";
  const LEGACY_STORAGE_KEY = "LiveNotebook_Sessions_v1"; // old localStorage key
  let dbPromise = null;

  // ---------------------------
  // Utility functions
  // ---------------------------

  function setStatus(text, mode) {
    statusText.textContent = text;
    statusDot.classList.remove("live", "idle");
    if (mode === "live") {
      statusDot.classList.add("live");
    } else {
      statusDot.classList.add("idle");
    }
  }

  function nowForName() {
    const d = new Date();
    const pad = (n) => String(n).padStart(2, "0");
    return (
      d.getFullYear() +
      "-" +
      pad(d.getMonth() + 1) +
      "-" +
      pad(d.getDate()) +
      "_" +
      pad(d.getHours()) +
      "-" +
      pad(d.getMinutes()) +
      "-" +
      pad(d.getSeconds())
    );
  }

  function formatDateTime(dtStr) {
    const d = new Date(dtStr);
    if (isNaN(d.getTime())) return dtStr;
    return d.toLocaleString();
  }

  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 0);
  }

  function downloadText(text, filename) {
    const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
    downloadBlob(blob, filename);
  }

  function blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result.split(",")[1]);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }

  function base64ToBlob(base64, mimeType) {
    const byteChars = atob(base64);
    const byteNumbers = new Array(byteChars.length);
    for (let i = 0; i < byteChars.length; i++) {
      byteNumbers[i] = byteChars.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    return new Blob([byteArray], { type: mimeType });
  }

  function setRecordingTimer(ms) {
    if (!recordingTimerText) return;
    const totalSec = Math.floor(ms / 1000);
    const m = Math.floor(totalSec / 60);
    const s = totalSec % 60;
    recordingTimerText.textContent =
      "Recording duration: " +
      String(m).padStart(2, "0") +
      ":" +
      String(s).padStart(2, "0");
  }

  function resetCurrentPlayingLabel() {
    if (currentPlayingSessionId && playButtonsBySession[currentPlayingSessionId]) {
      playButtonsBySession[currentPlayingSessionId].textContent = "‚ñ∂ Play";
    }
  }

  // ---------------------------
  // IndexedDB helpers
  // ---------------------------

  function getDB() {
    if (!dbPromise) {
      dbPromise = new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onupgradeneeded = (event) => {
          const db = request.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            const store = db.createObjectStore(STORE_NAME, { keyPath: "id" });
            store.createIndex("createdAt", "createdAt", { unique: false });
          }
        };
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }
    return dbPromise;
  }

  async function getAllSessions() {
    const db = await getDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, "readonly");
      const store = tx.objectStore(STORE_NAME);
      const req = store.getAll();
      req.onsuccess = () => {
        const arr = req.result || [];
        resolve(arr);
      };
      req.onerror = () => reject(req.error);
    });
  }

  async function getSessionById(id) {
    const db = await getDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, "readonly");
      const store = tx.objectStore(STORE_NAME);
      const req = store.get(id);
      req.onsuccess = () => resolve(req.result || null);
      req.onerror = () => reject(req.error);
    });
  }

  async function putSession(session) {
    const db = await getDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, "readwrite");
      const store = tx.objectStore(STORE_NAME);
      const req = store.put(session);
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }

  async function deleteSessionById(id) {
    const db = await getDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, "readwrite");
      const store = tx.objectStore(STORE_NAME);
      const req = store.delete(id);
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }

  async function clearAllSessions() {
    const db = await getDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, "readwrite");
      const store = tx.objectStore(STORE_NAME);
      const req = store.clear();
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }

  async function migrateLegacyLocalStorage() {
    try {
      const raw = localStorage.getItem(LEGACY_STORAGE_KEY);
      if (!raw) return;
      const arr = JSON.parse(raw);
      if (!Array.isArray(arr) || !arr.length) return;

      for (const s of arr) {
        if (!s.audioBase64) continue;
        const blob = base64ToBlob(s.audioBase64, s.mimeType || "audio/webm");
        const id =
          s.id ||
          s.createdAt ||
          new Date().toISOString() + "_" + Math.random().toString(36).slice(2);
        const sessionObj = {
          id,
          name: s.name || "Session_" + nowForName(),
          createdAt: s.createdAt || new Date().toISOString(),
          transcript: s.transcript || "",
          mimeType: s.mimeType || blob.type || "audio/webm",
          audioBlob: blob,
        };
        await putSession(sessionObj);
      }
      localStorage.removeItem(LEGACY_STORAGE_KEY);
      console.log("Legacy sessions migrated from localStorage to IndexedDB.");
    } catch (e) {
      console.error("Legacy migration error:", e);
    }
  }

  function updateSessionCount(sessions) {
    sessionCount.textContent =
      sessions.length === 1 ? "1 session" : sessions.length + " sessions";
  }

  // ---------------------------
  // Render session list
  // ---------------------------

  async function renderSessions() {
    const sessions = await getAllSessions();
    updateSessionCount(sessions);

    playButtonsBySession = {};
    sessionsList.innerHTML = "";
    if (!sessions.length) {
      sessionsList.innerHTML =
        '<div class="hint">No saved sessions yet. Record, stop, then click <strong>Save session</strong>.</div>';
      return;
    }

    sessions
      .slice()
      .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
      .forEach((session) => {
        const card = document.createElement("div");
        card.className = "session-card";

        const headerRow = document.createElement("div");
        headerRow.className = "session-header-row";

        const nameInput = document.createElement("input");
        nameInput.type = "text";
        nameInput.className = "session-name-input";
        nameInput.value = session.name || "";
        nameInput.title = "Rename session";

        nameInput.addEventListener("change", async () => {
          const newName = nameInput.value.trim();
          const full = await getSessionById(session.id);
          if (full) {
            full.name = newName || full.name;
            await putSession(full);
            renderSessions();
          }
        });

        const metaDiv = document.createElement("div");
        metaDiv.className = "session-meta";
        const sizeKB =
          session.audioBlob && session.audioBlob.size
            ? " ‚Ä¢ " + Math.round(session.audioBlob.size / 1024) + " KB"
            : "";
        metaDiv.innerHTML =
          '<span class="badge-pill">Saved</span> ' +
          formatDateTime(session.createdAt) +
          sizeKB;

        headerRow.appendChild(nameInput);
        headerRow.appendChild(metaDiv);

        const buttonsRow = document.createElement("div");
        buttonsRow.className = "session-buttons";

        const playBtn = document.createElement("button");
        playBtn.className = "btn-primary";
        playBtn.textContent = "‚ñ∂ Play";
        playBtn.dataset.sessionId = session.id;
        playButtonsBySession[session.id] = playBtn;

        playBtn.addEventListener("click", async () => {
          const id = session.id;

          // If same session is currently playing, toggle pause
          if (currentPlayingSessionId === id && !currentAudio.paused) {
            currentAudio.pause();
            return;
          }

          // Stop previous playback (if any)
          if (!currentAudio.paused) {
            currentAudio.pause();
          }
          if (currentAudioUrl) {
            URL.revokeObjectURL(currentAudioUrl);
            currentAudioUrl = null;
          }
          resetCurrentPlayingLabel();

          const full = await getSessionById(id);
          if (!full || !full.audioBlob) {
            alert("No audio found for this session.");
            return;
          }

          currentPlayingSessionId = id;
          const url = URL.createObjectURL(full.audioBlob);
          currentAudioUrl = url;
          currentAudio.src = url;
          currentAudio.load();
          playBtn.textContent = "‚è∏ Pause";

          try {
            await currentAudio.play();
          } catch (err) {
            console.error("Playback error:", err);
            resetCurrentPlayingLabel();
            currentPlayingSessionId = null;
          }
        });

        const dlAudioBtn = document.createElement("button");
        dlAudioBtn.className = "btn-ghost";
        dlAudioBtn.textContent = "‚¨á Audio";
        dlAudioBtn.addEventListener("click", async () => {
          const full = await getSessionById(session.id);
          if (!full || !full.audioBlob) {
            alert("No audio available for this session.");
            return;
          }
          const baseName = session.name || "Session_" + nowForName();
          downloadBlob(full.audioBlob, baseName + ".webm");
        });

        const dlTxtBtn = document.createElement("button");
        dlTxtBtn.className = "btn-ghost";
        dlTxtBtn.textContent = "‚¨á Transcript";
        dlTxtBtn.addEventListener("click", () => {
          const baseName = session.name || "Session_" + nowForName();
          downloadText(session.transcript || "", baseName + ".txt");
        });

        const delBtn = document.createElement("button");
        delBtn.className = "btn-danger";
        delBtn.textContent = "‚úï Delete";
        delBtn.addEventListener("click", async () => {
          await deleteSessionById(session.id);
          if (currentPlayingSessionId === session.id && !currentAudio.paused) {
            currentAudio.pause();
          }
          renderSessions();
        });

        buttonsRow.appendChild(playBtn);
        buttonsRow.appendChild(dlAudioBtn);
        buttonsRow.appendChild(dlTxtBtn);
        buttonsRow.appendChild(delBtn);

        const transcriptPreview = document.createElement("div");
        transcriptPreview.className = "hint";
        transcriptPreview.style.marginTop = "4px";
        const previewText =
          (session.transcript || "").slice(0, 100).replace(/\s+/g, " ");
        transcriptPreview.innerHTML =
          "<strong>Preview:</strong> " +
          (previewText
            ? previewText +
              (session.transcript && session.transcript.length > 100 ? "‚Ä¶" : "")
            : "<em>(empty)</em>");

        card.appendChild(headerRow);
        card.appendChild(buttonsRow);
        card.appendChild(transcriptPreview);
        sessionsList.appendChild(card);
      });
  }

  // Keep Play button label in sync when audio stops/pauses
  currentAudio.addEventListener("ended", () => {
    resetCurrentPlayingLabel();
    if (currentAudioUrl) {
      URL.revokeObjectURL(currentAudioUrl);
      currentAudioUrl = null;
    }
    currentPlayingSessionId = null;
  });

  currentAudio.addEventListener("pause", () => {
    resetCurrentPlayingLabel();
  });

  // ---------------------------
  // Speech recognition setup
  // ---------------------------

  function initRecognition() {
    if (!SpeechRecognition) return;
    recognition = new SpeechRecognition();
    recognition.lang = "en-US"; // change if needed
    recognition.interimResults = true;
    recognition.continuous = true;

    recognition.onstart = () => {
      recognizing = true;
      setStatus("Listening + recording‚Ä¶", "live");
    };

    recognition.onerror = (event) => {
      console.error("Speech recognition error:", event.error);
      setStatus("Speech error: " + event.error, "idle");
    };

    recognition.onend = () => {
      recognizing = false;
      if (stopBtn.disabled === false) {
        setStatus("Speech stopped. Click Start to resume.", "idle");
      }
    };

    recognition.onresult = (event) => {
      interimTranscript = "";
      for (let i = event.resultIndex; i < event.results.length; i++) {
        const res = event.results[i];
        if (res.isFinal) {
          finalTranscript += res[0].transcript + " ";
        } else {
          interimTranscript += res[0].transcript;
        }
      }
      transcriptArea.value = finalTranscript + "\n" + interimTranscript;
      transcriptArea.scrollTop = transcriptArea.scrollHeight;
    };
  }

  initRecognition();

  // ---------------------------
  // Audio recording setup
  // ---------------------------

  async function startRecording() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      alert("Audio recording not supported in this browser.");
      return;
    }

    const constraints = { audio: true };

    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    recordedChunks = [];

    let options = {};
    if (window.MediaRecorder && MediaRecorder.isTypeSupported("audio/webm;codecs=opus")) {
      options.mimeType = "audio/webm;codecs=opus";
    }

    mediaRecorder = new MediaRecorder(stream, options);

    mediaRecorder.ondataavailable = (e) => {
      if (e.data && e.data.size > 0) {
        recordedChunks.push(e.data);
      }
    };

    mediaRecorder.onstop = () => {
      const blob = new Blob(recordedChunks, {
        type: mediaRecorder.mimeType || "audio/webm",
      });
      currentAudioBlob = blob;

      // Reset any previous session playback state
      resetCurrentPlayingLabel();
      currentPlayingSessionId = null;
      if (currentAudioUrl) {
        URL.revokeObjectURL(currentAudioUrl);
        currentAudioUrl = null;
      }

      const url = URL.createObjectURL(blob);
      currentAudio.src = url;
      currentAudio.load();
      currentAudioUrl = url;

      saveSessionBtn.disabled = false;

      // Final timer update
      if (recordingStartTime !== null) {
        setRecordingTimer(Date.now() - recordingStartTime);
      }
    };

    mediaRecorder.start();

    // Start timer
    recordingStartTime = Date.now();
    setRecordingTimer(0);
    if (recordingTimerInterval) {
      clearInterval(recordingTimerInterval);
    }
    recordingTimerInterval = setInterval(() => {
      if (recordingStartTime !== null) {
        setRecordingTimer(Date.now() - recordingStartTime);
      }
    }, 1000);
  }

  function stopRecording() {
    if (mediaRecorder && mediaRecorder.state !== "inactive") {
      mediaRecorder.stop();
      mediaRecorder.stream.getTracks().forEach((t) => t.stop());
    }
    if (recordingTimerInterval) {
      clearInterval(recordingTimerInterval);
      recordingTimerInterval = null;
    }
    if (recordingStartTime !== null) {
      setRecordingTimer(Date.now() - recordingStartTime);
      recordingStartTime = null;
    }
  }

  // ---------------------------
  // Button handlers
  // ---------------------------

  startBtn.addEventListener("click", async () => {
    // reset current
    finalTranscript = "";
    interimTranscript = "";
    transcriptArea.value = "";
    currentAudio.src = "";
    currentAudioBlob = null;
    saveSessionBtn.disabled = true;
    resetCurrentPlayingLabel();
    currentPlayingSessionId = null;
    if (currentAudioUrl) {
      URL.revokeObjectURL(currentAudioUrl);
      currentAudioUrl = null;
    }
    setRecordingTimer(0);

    try {
      await startRecording();
      if (recognition && !recognizing) {
        recognition.start();
      }
      startBtn.disabled = true;
      stopBtn.disabled = false;
      setStatus("Listening + recording‚Ä¶", "live");
    } catch (e) {
      console.error(e);
      setStatus("Could not start recording: " + e.message, "idle");
    }
  });

  stopBtn.addEventListener("click", () => {
    stopRecording();
    if (recognition && recognizing) {
      recognition.stop();
    }
    startBtn.disabled = false;
    stopBtn.disabled = true;
    setStatus("Stopped. You can review, then Save session.", "idle");
  });

  saveSessionBtn.addEventListener("click", async () => {
    if (!currentAudioBlob) {
      alert("No audio recorded. Please record first.");
      return;
    }

    const text = transcriptArea.value || "";
    const nameRaw = sessionNameInput.value.trim();
    const name = nameRaw || "Session_" + nowForName(); // if no input, use date
    const createdAt = new Date().toISOString();
    const mimeType = currentAudioBlob.type || "audio/webm";

    setStatus("Saving session locally‚Ä¶", "idle");
    saveSessionBtn.disabled = true;

    try {
      const session = {
        id: createdAt + "_" + Math.random().toString(36).slice(2),
        name,
        createdAt,
        transcript: text,
        mimeType,
        audioBlob: currentAudioBlob,
      };
      await putSession(session);
      await renderSessions();
      setStatus("Session saved locally.", "idle");
    } catch (e) {
      console.error("Failed to save session:", e);
      setStatus("Error saving session: " + e.message, "idle");
    } finally {
      saveSessionBtn.disabled = false;
    }
  });

  // Backup: export all
  exportBtn.addEventListener("click", async () => {
    const sessions = await getAllSessions();
    const exportArr = [];
    for (const s of sessions) {
      let audioBase64 = null;
      if (s.audioBlob) {
        audioBase64 = await blobToBase64(s.audioBlob);
      }
      exportArr.push({
        id: s.id,
        name: s.name,
        createdAt: s.createdAt,
        transcript: s.transcript,
        mimeType: s.mimeType,
        audioBase64,
      });
    }
    const blob = new Blob([JSON.stringify(exportArr, null, 2)], {
      type: "application/json;charset=utf-8",
    });
    const filename = "LiveNotebook_Backup_" + nowForName() + ".json";
    downloadBlob(blob, filename);
  });

  // Clear all
  clearAllBtn.addEventListener("click", async () => {
    if (!confirm("Delete ALL saved sessions from this browser?")) return;
    await clearAllSessions();
    resetCurrentPlayingLabel();
    currentPlayingSessionId = null;
    if (currentAudioUrl) {
      URL.revokeObjectURL(currentAudioUrl);
      currentAudioUrl = null;
    }
    await renderSessions();
  });

  // Import
  importFileInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async () => {
      try {
        const imported = JSON.parse(reader.result);
        if (!Array.isArray(imported)) {
          alert("Invalid file format (expected array).");
          return;
        }
        for (const item of imported) {
          if (!item.audioBase64) continue;
          const blob = base64ToBlob(
            item.audioBase64,
            item.mimeType || "audio/webm"
          );
          const id =
            item.id ||
            item.createdAt ||
            new Date().toISOString() +
              "_" +
              Math.random().toString(36).slice(2);
          const obj = {
            id,
            name: item.name || "Imported_" + nowForName(),
            createdAt: item.createdAt || new Date().toISOString(),
            transcript: item.transcript || "",
            mimeType: item.mimeType || blob.type || "audio/webm",
            audioBlob: blob,
          };
          await putSession(obj);
        }
        await renderSessions();
        alert("Import complete. Sessions merged.");
      } catch (err) {
        console.error("Import error:", err);
        alert("Failed to import file: " + err.message);
      }
    };
    reader.readAsText(file);
    // reset input so same file can be selected again if needed
    e.target.value = "";
  });

  // ---------------------------
  // Init
  // ---------------------------

  (async function initApp() {
    setRecordingTimer(0);
    await migrateLegacyLocalStorage();
    await renderSessions();
  })();
</script>
</body>
</html>
