<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Auto Two-Language Conversation Translator</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  :root {
    --bg:#020617; --card:#020617; --border:#1f2937;
    --accent:#0ea5e9; --accent-soft:rgba(56,189,248,0.15);
    --text:#e5e7eb; --muted:#9ca3af; --danger:#fecaca;
  }

  * { box-sizing:border-box; }

  body {
    margin:0; padding:14px;
    background:radial-gradient(circle at top,#1f2937,#020617 50%);
    font-family:system-ui,-apple-system,BlinkMacSystemFont;
    color:var(--text);
  }

  .app {
    max-width:900px; margin:auto;
    background:var(--card); padding:16px;
    border-radius:16px; border:1px solid var(--border);
    box-shadow:0 20px 45px rgba(0,0,0,0.6);
  }

  h1 { font-size:1.2rem; margin:0 0 6px; }
  .subtitle { font-size:.8rem; color:var(--muted); margin-bottom:10px; }

  textarea {
    width:100%; min-height:230px;
    padding:8px;
    background:#020617; color:var(--text);
    border-radius:10px; border:1px solid var(--border);
    font-size:.9rem; resize:vertical;
  }
  textarea:focus {
    outline:none; border-color:var(--accent);
    box-shadow:0 0 0 1px var(--accent-soft);
  }

  select {
    width:100%; padding:10px; margin-top:4px;
    background:#020617; color:var(--text);
    border-radius:8px; border:1px solid var(--border);
    font-size:.9rem;
  }

  .pair-row {
    display:grid;
    grid-template-columns:repeat(2, minmax(0, 1fr));
    gap:10px;
    margin-top:10px;
  }

  button {
    border:none; border-radius:999px;
    padding:12px; cursor:pointer;
    font-size:.9rem;
  }

  .btn-rec { background:#ef4444; color:white; width:100%; }
  .btn-stop { background:#475569; color:white; width:100%; }

  .btn-copy  { background:#38bdf8; color:#0b1120; width:100%; }
  .btn-clear { background:#1e293b; color:white; width:100%; }
  .btn-speak { background:#10b981; color:white; width:100%; }
  .btn-save  { background:#22c55e; color:#052e16; width:100%; }

  .conv-box {
    margin-top:6px; padding:10px;
    background:#020617;
    border:1px solid var(--border);
    border-radius:12px;
    max-height:240px;
    overflow-y:auto;
    font-size:.8rem;
    white-space:pre-wrap;
  }

  .status-row {
    display:flex;
    align-items:center;
    justify-content:space-between;
    margin-top:6px;
  }

  .status { font-size:.75rem; color:var(--muted); }

  .error  { min-height:18px; font-size:.78rem; color:var(--danger); }

  .wave {
    display:flex;
    gap:4px;
    height:16px;
    align-items:flex-end;
  }
  .wave span {
    width:3px;
    border-radius:999px;
    background:var(--accent);
    animation: wave 1s infinite ease-in-out;
    opacity:.25;
  }
  .wave span:nth-child(2){ animation-delay:.15s; }
  .wave span:nth-child(3){ animation-delay:.30s; }
  .wave span:nth-child(4){ animation-delay:.45s; }

  .wave.listening span { opacity:1; }

  @keyframes wave {
    0%,100% { transform:scaleY(0.3); }
    50%     { transform:scaleY(1.2); }
  }

  .label-small {
    font-size:.8rem;
    margin-top:6px;
    display:block;
  }
</style>
</head>

<body>
<div class="app">
  <h1>üåê Auto Two-Language Conversation Translator</h1>
  <div class="subtitle">
    Choose two languages (Source / Partner).  
    Speak either one. It auto-detects which and translates to the other.  
    Chinese / Japanese / Korean / Thai show script + romanization + translation.
  </div>

  <!-- Row 1: Start / Stop -->
  <div class="pair-row">
    <button id="startSpeech" class="btn-rec">üé§ Start Speech</button>
    <button id="stopSpeech"  class="btn-stop">‚èπ Stop</button>
  </div>

  <!-- Row 2: Status + waveform -->
  <div class="status-row">
    <div id="statusText" class="status">Status: Idle</div>
    <div id="voiceWave" class="wave">
      <span></span><span></span><span></span><span></span>
    </div>
  </div>

  <!-- Row 3: Language dropdowns in one row -->
  <div class="pair-row" style="margin-top:10px;">
    <div>
      <span class="label-small">Source language</span>
      <select id="sourceLang">
        <option value="en" selected>English</option>
        <option value="tl">Filipino</option>
        <option value="zh-CN">Chinese</option>
        <option value="ja">Japanese</option>
        <option value="ko">Korean</option>
        <option value="th">Thai</option>
      </select>
    </div>
    <div>
      <span class="label-small">Partner language</span>
      <select id="targetLang">
        <option value="zh-CN">Chinese</option>
        <option value="en">English</option>
        <option value="tl">Filipino</option>
        <option value="ja">Japanese</option>
        <option value="ko">Korean</option>
        <option value="th">Thai</option>
      </select>
    </div>
  </div>

  <!-- Row 4: textareas -->
  <div class="pair-row" style="margin-top:10px;">
    <textarea id="sourceText" placeholder="Live speech transcript will appear here‚Ä¶"></textarea>
    <textarea id="targetText" readonly placeholder="Live translation will appear here‚Ä¶"></textarea>
  </div>

  <!-- Row 5: Copy / Clear -->
  <div class="pair-row" style="margin-top:10px;">
    <button id="btnCopy"  class="btn-copy">üìã Copy Translation</button>
    <button id="btnClear" class="btn-clear">üßπ Clear</button>
  </div>

  <!-- Row 6: Speak / Save -->
  <div class="pair-row" style="margin-top:10px;">
    <button id="btnSpeak"         class="btn-speak">üîä Speak Translation</button>
    <button id="btnSaveTranscript" class="btn-save">üíæ Save Transcript</button>
  </div>

  <!-- Voice choice -->
  <span class="label-small">Voice for Speak Translation</span>
  <select id="voiceSelect">
    <option value="auto" selected>Auto (best match)</option>
  </select>

  <!-- Transcript -->
  <div style="font-size:.8rem;margin-top:12px;color:var(--muted);">Conversation Transcript</div>
  <div id="conversationBox" class="conv-box">No conversation yet.</div>

  <div id="errorBox" class="error"></div>
</div>

<!-- Pinyin for Chinese -->
<script src="https://cdn.jsdelivr.net/npm/pinyin-pro@3.27.0/dist/index.js"></script>
<!-- franc-min for 2-language detection -->
<script src="https://cdn.jsdelivr.net/npm/franc-min@5/dist/franc-min.min.js"></script>

<script>
/* ---------- DOM ---------- */
const startSpeechBtn   = document.getElementById("startSpeech");
const stopSpeechBtn    = document.getElementById("stopSpeech");
const sourceText       = document.getElementById("sourceText");
const targetText       = document.getElementById("targetText");
const sourceLangSel    = document.getElementById("sourceLang");
const targetLangSel    = document.getElementById("targetLang");
const statusText       = document.getElementById("statusText");
const errorBox         = document.getElementById("errorBox");
const btnCopy          = document.getElementById("btnCopy");
const btnClear         = document.getElementById("btnClear");
const btnSpeak         = document.getElementById("btnSpeak");
const btnSaveTrans     = document.getElementById("btnSaveTranscript");
const conversationBox  = document.getElementById("conversationBox");
const voiceWave        = document.getElementById("voiceWave");
const voiceSelect      = document.getElementById("voiceSelect");

/* ---------- State ---------- */
let transcriptEntries  = [];
let typingDebounce     = null;
let keepListening      = false;

/* last translation info (for transcript + TTS) */
let lastSrcLang = "";
let lastTgtLang = "";
let lastSourceText = "";
let lastTranslatedText = "";

/* live speech buffers */
let liveFinalBuffer = "";
let liveInterimText = "";

/* voices */
let allVoices = [];
let currentRecBase = "en";   // which base language SR is currently set to
let lastDetectedSide = "A";  // "A"=source, "B"=target

/* ---------- Helpers ---------- */
function baseFromLang(code){
  if (!code) return "";
  if (code.startsWith("zh")) return "zh";
  if (code.startsWith("en")) return "en";
  if (code.startsWith("tl")) return "tl";
  if (code.startsWith("ja")) return "ja";
  if (code.startsWith("ko")) return "ko";
  if (code.startsWith("th")) return "th";
  return code;
}

function isEastAsianBase(base){
  return base === "zh" || base === "ja" || base === "ko" || base === "th";
}

function isEastAsian(code){
  return isEastAsianBase(baseFromLang(code));
}

function scrollToBottomAndFocus(el){
  const len = el.value.length;
  el.selectionStart = el.selectionEnd = len;
  el.scrollTop = el.scrollHeight;
}

function srCodeFromBase(base){
  switch(base){
    case "en": return "en-US";
    case "tl": return "fil-PH";
    case "zh": return "zh-CN";
    case "ja": return "ja-JP";
    case "ko": return "ko-KR";
    case "th": return "th-TH";
    default:   return "en-US";
  }
}

function ttsCodeFromLang(code){
  return srCodeFromBase(baseFromLang(code));
}

/* script detection: returns base "zh","ja","ko","th" or null */
function detectScriptBase(text){
  if (!text) return null;
  const t = text;
  const hasHan    = /\p{Script=Han}/u.test(t);
  const hasHira   = /[\u3040-\u309F]/.test(t);
  const hasKata   = /[\u30A0-\u30FF]/.test(t);
  const hasHangul = /[\uAC00-\uD7AF]/.test(t);
  const hasThai   = /[\u0E00-\u0E7F]/.test(t);

  if (hasHan)               return "zh";
  if (hasHira || hasKata)   return "ja";
  if (hasHangul)            return "ko";
  if (hasThai)              return "th";
  return null;
}

/* franc-min between two languages only */
function detectByFranc(text, baseA, baseB){
  if (!window.franc || !text || text.length < 5) return null;
  const mapBaseToIso = { en:"eng", tl:"tgl", zh:"cmn", ja:"jpn", ko:"kor", th:"tha" };
  const isoA = mapBaseToIso[baseA];
  const isoB = mapBaseToIso[baseB];
  const only = [];
  if (isoA) only.push(isoA);
  if (isoB && isoB !== isoA) only.push(isoB);
  if (!only.length) return null;

  try {
    const iso = window.franc(text, {only});
    if (!iso || iso === "und") return null;
    const mapIsoToBase = { eng:"en", tgl:"tl", cmn:"zh", jpn:"ja", kor:"ko", tha:"th" };
    return mapIsoToBase[iso] || null;
  } catch(e){
    return null;
  }
}

/* Auto-detect which side (A=source, B=partner) is speaking */
function detectSide(text, langA, langB){
  const baseA = baseFromLang(langA);
  const baseB = baseFromLang(langB);

  if (baseA === baseB){
    return lastDetectedSide || "A";
  }

  // 1) script detection
  const scriptBase = detectScriptBase(text);
  if (scriptBase){
    if (scriptBase === baseA && scriptBase !== baseB) return "A";
    if (scriptBase === baseB && scriptBase !== baseA) return "B";
    // if both languages use same script (rare for EA here), fall through
  }

  // 2) franc-min only between A & B
  const francBase = detectByFranc(text, baseA, baseB);
  if (francBase){
    if (francBase === baseA) return "A";
    if (francBase === baseB) return "B";
  }

  // 3) fallback: keep previous, or default to A
  return lastDetectedSide || "A";
}

/* ---------- Speech Recognition ---------- */
let SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
let recognition = null;

if (SpeechRecognition){
  recognition = new SpeechRecognition();
  recognition.continuous = true;
  recognition.interimResults = true;
} else {
  statusText.textContent = "Status: Speech recognition not supported.";
}

function updateRecognizerLanguage(base){
  if (!recognition) return;
  if (base && base !== currentRecBase){
    currentRecBase = base;
    try {
      recognition.lang = srCodeFromBase(base);
    } catch(e){}
  }
}

/* Start / Stop */
startSpeechBtn.onclick = () => {
  if (!recognition) return;
  if (keepListening) return;
  keepListening = true;
  liveFinalBuffer = "";
  liveInterimText = "";
  const baseA = baseFromLang(sourceLangSel.value);
  currentRecBase = baseA || "en";
  updateRecognizerLanguage(currentRecBase);
  try { recognition.start(); } catch(e){}
  voiceWave.classList.add("listening");
  statusText.textContent = "Status: Listening‚Ä¶";
};

stopSpeechBtn.onclick = async () => {
  if (!recognition) return;
  keepListening = false;
  recognition.stop();
  voiceWave.classList.remove("listening");

  const currentText = sourceText.value.trim();
  if (currentText){
    await doTranslate(); // ensures last* filled
    if (lastTranslatedText){
      appendToTranscript(lastSrcLang, lastTgtLang, lastSourceText, lastTranslatedText);
    }
  }
  statusText.textContent = "Status: Stopped.";
};

/* Live speech: update text & translation (no transcript here) */
if (recognition){
  recognition.onresult = (event) => {
    for (let i = event.resultIndex; i < event.results.length; i++){
      const res = event.results[i];
      if (res.isFinal){
        liveFinalBuffer += res[0].transcript + " ";
        liveInterimText = "";
      } else {
        liveInterimText = res[0].transcript;
      }
    }

    let full = (liveFinalBuffer + " " + liveInterimText).trim();
    if (!full) return;

    full = full.replace(/([a-z])([A-Z])/g, "$1 $2"); // readability for English

    sourceText.value = full;
    scrollToBottomAndFocus(sourceText);
    doTranslate();  // live translation while speaking
  };

  recognition.onerror = (e) => {
    console.error(e);
    voiceWave.classList.remove("listening");
    statusText.textContent = "Status: Speech error.";
  };

  recognition.onend = () => {
    if (keepListening){
      try { recognition.start(); } catch(e){}
    } else {
      voiceWave.classList.remove("listening");
    }
  };
}

/* ---------- Google Translate helpers ---------- */
async function gTransRaw(text, sl, tl, extra=""){
  const url =
    "https://translate.googleapis.com/translate_a/single?client=gtx" +
    `&sl=${encodeURIComponent(sl)}&tl=${encodeURIComponent(tl)}&dt=t${extra}&q=${encodeURIComponent(text)}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error("Network error " + res.status);
  return res.json();
}

function extText(data){
  if (!data || !data[0]) return "";
  return data[0].map(seg => seg[0]).join("");
}

function extRoman(data){
  if (!data || !data[0]) return "";
  const parts = [];
  for (const seg of data[0]){
    if (seg[3]) parts.push(seg[3]);
  }
  return parts.join(" ").trim();
}

/* ---------- Core Translation (auto A‚ÜîB) ---------- */
async function doTranslate(){
  const text = sourceText.value.trim();
  if (!text){
    targetText.value = "";
    statusText.textContent = "Status: Idle";
    return;
  }

  const langA = sourceLangSel.value;
  const langB = targetLangSel.value;
  const baseA = baseFromLang(langA);
  const baseB = baseFromLang(langB);

  // detect which side is speaking, but only A/B
  let side = detectSide(text, langA, langB);
  if (!side) side = "A";
  lastDetectedSide = side;

  let sl, tl; // sl = spoken language, tl = target language
  if (side === "A"){
    sl = langA;
    tl = langB;
  } else {
    sl = langB;
    tl = langA;
  }

  // adjust speech recognition language for future chunks
  if (recognition && keepListening){
    const newBase = baseFromLang(sl);
    updateRecognizerLanguage(newBase);
  }

  const slBase = baseFromLang(sl);
  const tlBase = baseFromLang(tl);
  const slEA   = isEastAsian(sl);
  const tlEA   = isEastAsian(tl);

  statusText.textContent = `Status: Translating (${sl} ‚Üí ${tl})‚Ä¶`;
  errorBox.textContent   = "";

  try {
    let display = "";

    if (slEA || tlEA){
      let scriptLang, meaningLang;

      if (slEA && !tlEA){
        scriptLang  = sl;
        meaningLang = tl;
      } else if (!slEA && tlEA){
        scriptLang  = tl;
        meaningLang = sl;
      } else {
        scriptLang  = tl;
        meaningLang = (slBase === "en" || tlBase === "en") ? "en" : sl;
      }

      const scriptText  = extText(await gTransRaw(text, sl, scriptLang));
      const meaningText = extText(await gTransRaw(text, sl, meaningLang));

      let roman = "";
      const sBase = baseFromLang(scriptLang);
      if (sBase === "zh"){
        if (window.pinyinPro){
          roman = window.pinyinPro.pinyin(scriptText, {toneType:"mark", type:"string"});
        }
      } else if (sBase === "ja"){
        try {
          const rawJa = await gTransRaw(scriptText, "ja", "ja", "&dt=rm");
          roman = extRoman(rawJa);
        } catch(e){}
      } else if (sBase === "ko" || sBase === "th"){
        try {
          const raw = await gTransRaw(scriptText, scriptLang, scriptLang, "&dt=rm");
          roman = extRoman(raw);
        } catch(e){}
      }

      display = scriptText;
      if (roman) display += "\n" + roman;
      display += "\n" + meaningText;

    } else {
      const translated = extText(await gTransRaw(text, sl, tl));
      display = translated;
    }

    targetText.value = display;
    scrollToBottomAndFocus(targetText);

    lastSrcLang = sl;
    lastTgtLang = tl;
    lastSourceText = text;
    lastTranslatedText = display;

    statusText.textContent = "Status: Done.";
  } catch(err){
    console.error(err);
    errorBox.textContent   = "Error: " + err.message;
    statusText.textContent = "Status: Error.";
  }
}

/* ---------- Typing auto-translate ---------- */
sourceText.addEventListener("input", () => {
  clearTimeout(typingDebounce);
  typingDebounce = setTimeout(() => {
    scrollToBottomAndFocus(sourceText);
    doTranslate();
  }, 350);
});

/* ---------- Dropdown change ---------- */
function onLangChange(){
  // reset recognizer base to Source language
  const baseA = baseFromLang(sourceLangSel.value);
  currentRecBase = baseA || "en";
  updateRecognizerLanguage(currentRecBase);
  if (sourceText.value.trim()){
    doTranslate();
  }
}
sourceLangSel.addEventListener("change", onLangChange);
targetLangSel.addEventListener("change", onLangChange);

/* ---------- Transcript ---------- */
function appendToTranscript(sl, tl, src, out){
  const time = new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit", second:"2-digit"});
  transcriptEntries.push(
`[${time}] (${sl} ‚Üí ${tl})
Source     : ${src}
Translation: ${out}`
  );
  conversationBox.textContent = transcriptEntries.join("\n\n");
  conversationBox.scrollTop = conversationBox.scrollHeight;
}

/* ---------- Save transcript ---------- */
btnSaveTrans.onclick = () => {
  if (!transcriptEntries.length){
    errorBox.textContent = "No transcript yet.";
    return;
  }
  errorBox.textContent = "";
  const content = transcriptEntries.join("\n\n");
  const blob = new Blob([content], {type:"text/plain"});
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement("a");

  const d = new Date();
  const fn = `transcript_${d.getFullYear()}${String(d.getMonth()+1).padStart(2,"0")}${String(d.getDate()).padStart(2,"0")}_${String(d.getHours()).padStart(2,"0")}${String(d.getMinutes()).padStart(2,"0")}${String(d.getSeconds()).padStart(2,"0")}.txt`;

  a.href = url;
  a.download = fn;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);

  statusText.textContent = "Status: Transcript saved.";
};

/* ---------- Voices ---------- */
function loadVoices(){
  if (!window.speechSynthesis) return;
  allVoices = window.speechSynthesis.getVoices() || [];
}

function populateVoiceOptions(speakLang){
  if (!window.speechSynthesis || !voiceSelect) return;
  if (!speakLang){
    const fallbackCode = lastTgtLang || targetLangSel.value;
    speakLang = ttsCodeFromLang(fallbackCode);
  }
  loadVoices();

  const prev = voiceSelect.value || "auto";
  voiceSelect.innerHTML = "";
  const autoOpt = document.createElement("option");
  autoOpt.value = "auto";
  autoOpt.textContent = "Auto (best match)";
  voiceSelect.appendChild(autoOpt);

  const base = speakLang.split("-")[0].toLowerCase();
  const matches = allVoices
    .map((v, idx) => ({v, idx}))
    .filter(({v}) => {
      const lang = (v.lang || "").toLowerCase();
      return lang === speakLang.toLowerCase() || lang.startsWith(base + "-");
    });

  const list = matches.length ? matches : allVoices.map((v, idx)=>({v,idx}));

  list.forEach(({v, idx}) => {
    const opt = document.createElement("option");
    opt.value = String(idx);
    opt.textContent = `${v.name} (${v.lang})`;
    voiceSelect.appendChild(opt);
  });

  const hasPrev = Array.from(voiceSelect.options).some(o => o.value === prev);
  voiceSelect.value = hasPrev ? prev : "auto";
}

if (window.speechSynthesis){
  window.speechSynthesis.onvoiceschanged = () => {
    loadVoices();
    populateVoiceOptions();
  };
  loadVoices();
  populateVoiceOptions();
}

/* ---------- Speak Translation ---------- */
btnSpeak.onclick = async () => {
  const txt = targetText.value.trim();
  if (!txt){
    statusText.textContent = "Status: Nothing to speak.";
    return;
  }

  const lines = txt.split("\n").map(l => l.trim()).filter(Boolean);
  if (!lines.length){
    statusText.textContent = "Status: Nothing to speak.";
    return;
  }

  const tgtLangForTTS = lastTgtLang || targetLangSel.value;
  const speakLang = ttsCodeFromLang(tgtLangForTTS);
  const tgtBase = baseFromLang(tgtLangForTTS);
  const speakText = isEastAsianBase(tgtBase) ? lines[0] : lines[lines.length - 1];

  if (!window.speechSynthesis){
    statusText.textContent = "Status: Speech not supported.";
    return;
  }

  // ensure voices loaded and options reflect current language
  await new Promise(resolve => {
    const v = window.speechSynthesis.getVoices();
    if (v && v.length){
      allVoices = v;
      return resolve();
    }
    window.speechSynthesis.onvoiceschanged = () => {
      allVoices = window.speechSynthesis.getVoices() || [];
      resolve();
    };
  });
  populateVoiceOptions(speakLang);

  let voice = null;

  // 1) user-selected
  if (voiceSelect && voiceSelect.value !== "auto"){
    const idx = parseInt(voiceSelect.value, 10);
    if (!isNaN(idx) && allVoices[idx]) voice = allVoices[idx];
  }

  // 2) auto best
  if (!voice){
    const base = speakLang.split("-")[0].toLowerCase();
    const candidates = allVoices.filter(v => {
      const lang = (v.lang || "").toLowerCase();
      return lang === speakLang.toLowerCase() || lang.startsWith(base + "-");
    });
    const pool = candidates.length ? candidates : allVoices;

    let female = pool.find(v =>
      (/female/i.test(v.name) || /Â•≥/i.test(v.name))
    );
    if (!female){
      female = pool.find(v =>
        /Google|Samantha|Kyoko|Mei-Jia|Ting-Ting|Yuna/i.test(v.name)
      );
    }
    voice = female || pool[0] || null;
  }

  const utter = new SpeechSynthesisUtterance(speakText);
  if (voice){
    utter.voice = voice;
    utter.lang  = voice.lang || speakLang;
  } else {
    utter.lang  = speakLang;
  }
  utter.rate  = 1.0;
  utter.pitch = 1.0;

  window.speechSynthesis.cancel();
  window.speechSynthesis.speak(utter);
  statusText.textContent = `Status: Speaking (${voice ? voice.name : speakLang})‚Ä¶`;
};

/* ---------- Copy & Clear ---------- */
btnCopy.onclick = async () => {
  const txt = targetText.value.trim();
  if (!txt) return;
  try {
    await navigator.clipboard.writeText(txt);
    statusText.textContent = "Status: Translation copied.";
  } catch {
    statusText.textContent = "Status: Copy failed.";
  }
};

btnClear.onclick = () => {
  sourceText.value = "";
  targetText.value = "";
  errorBox.textContent = "";
  statusText.textContent = "Status: Idle";
  lastSrcLang = lastTgtLang = lastSourceText = lastTranslatedText = "";
  liveFinalBuffer = "";
  liveInterimText = "";
  lastDetectedSide = "A";
};
</script>

</body>
</html>