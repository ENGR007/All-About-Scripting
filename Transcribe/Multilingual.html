<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Multi-Language Speech Translator (Enhanced Mic)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
:root {
  --bg:#020617; --card:#020617; --border:#1f2937;
  --accent:#0ea5e9; --accent-soft:rgba(56,189,248,0.15);
  --text:#e5e7eb; --muted:#9ca3af; --danger:#fecaca;
}
*{box-sizing:border-box;}
body{
  margin:0;padding:14px;
  background:radial-gradient(circle at top,#1f2937,#020617 50%);
  font-family:system-ui,-apple-system,BlinkMacSystemFont;
  color:var(--text);
}
.app{
  max-width:900px;margin:auto;
  background:var(--card);padding:16px;
  border-radius:16px;border:1px solid var(--border);
  box-shadow:0 20px 45px rgba(0,0,0,.6);
}
h1{font-size:1.2rem;margin:0 0 6px;display:flex;gap:8px;}
.subtitle{font-size:.8rem;color:var(--muted);margin-bottom:10px;}
textarea{
  width:100%;min-height:140px;padding:8px;
  background:#020617;color:var(--text);
  border:1px solid var(--border);border-radius:10px;
  font-size:.9rem;
}
textarea:focus{
  outline:none;border-color:var(--accent);
  box-shadow:0 0 0 1px var(--accent-soft);
}
select{
  width:100%;padding:10px;margin-top:8px;
  background:#020617;color:var(--text);
  border-radius:8px;border:1px solid var(--border);
}
.row{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:10px;}
@media(max-width:720px){.row{grid-template-columns:1fr;}}

button{
  border:none;padding:10px;
  border-radius:999px;cursor:pointer;
  font-size:.9rem;display:flex;justify-content:center;
}
.btn-rec{background:#ef4444;color:white;margin-top:12px;}
.btn-stop{background:#475569;color:white;margin-top:6px;}
.btn-copy{background:#38bdf8;color:#0b1120;}
.btn-clear{background:#1e293b;color:white;}

.status{margin-top:10px;font-size:.75rem;color:var(--muted);}
.error{color:var(--danger);font-size:.78rem;min-height:16px;}

/* Mic enhancement / VAD UI */
.mic-section{
  margin-top:10px;padding:8px 10px;
  border-radius:12px;background:#020617;
  border:1px solid var(--border);
}
.mic-label{font-size:.78rem;color:var(--muted);}
.level-bar{
  width:100%;height:10px;margin-top:5px;
  border-radius:999px;background:#111827;
  overflow:hidden;
}
.level-fill{
  height:100%;width:0%;
  background:#22c55e;
  transition:width .08s linear;
}
.talk-text{
  margin-top:5px;font-size:.78rem;
  color:var(--muted);
}
.talk-text.active{color:#22c55e;}
</style>
</head>

<body>
<div class="app">
  <h1>üåê Multi-Language Speech Translator</h1>
  <div class="subtitle">
    Filipino, English, Chinese(Pinyin), Japanese(Romaji), Korean & Thai (romanized).  
    Enhanced mic with voice detection for slightly-far speakers.
  </div>

  <button id="startSpeech" class="btn-rec">üé§ Start Speech</button>
  <button id="stopSpeech" class="btn-stop">‚èπ Stop</button>

  <div class="mic-section">
    <div class="mic-label">Mic Level / Voice Detection</div>
    <div class="level-bar">
      <div id="levelFill" class="level-fill"></div>
    </div>
    <div id="talkText" class="talk-text">Mic idle</div>
  </div>

  <select id="sourceLang">
    <option value="tl">Filipino</option>
    <option value="en">English</option>
    <option value="zh-CN">Chinese üá®üá≥ ‚Üí Pinyin</option>
    <option value="ja">Japanese üáØüáµ ‚Üí Romaji</option>
    <option value="ko">Korean üá∞üá∑ ‚Üí Romanization</option>
    <option value="th">Thai üáπüá≠ ‚Üí Romanization (RTGS)</option>
  </select>

  <select id="targetLang">
    <option value="en">English</option>
    <option value="tl">Filipino</option>
    <option value="zh-CN">Chinese üá®üá≥ ‚Üí Pinyin</option>
    <option value="ja">Japanese üáØüáµ ‚Üí Romaji</option>
    <option value="ko">Korean üá∞üá∑ ‚Üí Romanization</option>
    <option value="th">Thai üáπüá≠ ‚Üí Romanization (RTGS)</option>
  </select>

  <div class="row">
    <textarea id="sourceText" placeholder="Speak or type here‚Ä¶"></textarea>
    <textarea id="targetText" readonly placeholder="Translation appears here‚Ä¶"></textarea>
  </div>

  <div class="row">
    <button id="btnCopy" class="btn-copy">üìã Copy</button>
    <button id="btnClear" class="btn-clear">üßπ Clear</button>
  </div>

  <div id="statusText" class="status">Status: Idle</div>
  <div id="errorBox" class="error"></div>
</div>

<script>
/* DOM references */
const startSpeechBtn = document.getElementById("startSpeech");
const stopSpeechBtn  = document.getElementById("stopSpeech");
const sourceText     = document.getElementById("sourceText");
const targetText     = document.getElementById("targetText");
const sourceLang     = document.getElementById("sourceLang");
const targetLang     = document.getElementById("targetLang");
const statusText     = document.getElementById("statusText");
const errorBox       = document.getElementById("errorBox");
const btnCopy        = document.getElementById("btnCopy");
const btnClear       = document.getElementById("btnClear");
const levelFill      = document.getElementById("levelFill");
const talkText       = document.getElementById("talkText");

/* ==========================
   1. Speech Recognition
========================== */
let SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
let recognition;
let micActive = false;

if (SpeechRecognition) {
  recognition = new SpeechRecognition();
  recognition.continuous = true;
  recognition.interimResults = true;

  // iPhone-safe setting: English engine, can still hear Filipino/others reasonably
  recognition.lang = "en-US";
} else {
  statusText.innerText = "Status: Speech recognition not supported.";
}

/* ==========================
   2. Mic Enhancement / VAD
========================== */
let audioCtx = null;
let analyser = null;
let dataArray = null;
let micStream = null;
let rafId = null;

async function startAudioProcessing() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    return;
  }
  try {
    micStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        noiseSuppression: true,
        autoGainControl: true,
        echoCancellation: true,
        channelCount: 1
      }
    });
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const source = audioCtx.createMediaStreamSource(micStream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    dataArray = new Uint8Array(analyser.fftSize);
    source.connect(analyser);
    micActive = true;
    updateLevel();
  } catch (e) {
    console.error(e);
    errorBox.textContent = "Mic meter error: " + e.message;
  }
}

function updateLevel() {
  if (!analyser) return;
  analyser.getByteTimeDomainData(dataArray);
  let sum = 0;
  for (let i = 0; i < dataArray.length; i++) {
    const v = (dataArray[i] - 128) / 128;
    sum += v * v;
  }
  const rms = Math.sqrt(sum / dataArray.length); // 0..1
  const level = Math.min(1, rms * 5); // boost visual
  const percent = Math.round(level * 100);
  levelFill.style.width = percent + "%";

  if (percent > 8) {
    talkText.textContent = "Voice detected (even if a bit far)";
    talkText.classList.add("active");
  } else {
    talkText.textContent = "Mic on, waiting for voice‚Ä¶";
    talkText.classList.remove("active");
  }

  if (micActive) {
    rafId = requestAnimationFrame(updateLevel);
  }
}

function stopAudioProcessing() {
  micActive = false;
  if (rafId) cancelAnimationFrame(rafId);
  rafId = null;
  if (analyser) analyser.disconnect();
  analyser = null;
  if (audioCtx) {
    audioCtx.close();
    audioCtx = null;
  }
  if (micStream) {
    micStream.getTracks().forEach(t => t.stop());
    micStream = null;
  }
  levelFill.style.width = "0%";
  talkText.textContent = "Mic off";
  talkText.classList.remove("active");
}

/* ==========================
   3. Hook up Start / Stop
========================== */
startSpeechBtn.onclick = async () => {
  if (!recognition) return;
  errorBox.textContent = "";
  try {
    await startAudioProcessing();
    recognition.start();
    statusText.innerText = "Status: Listening‚Ä¶";
  } catch (e) {
    console.error(e);
    errorBox.textContent = "Mic error: " + e.message;
  }
};

stopSpeechBtn.onclick = () => {
  if (recognition) recognition.stop();
  stopAudioProcessing();
  statusText.innerText = "Status: Stopped.";
};

/* Auto-restart recognition while micActive (Safari drops sometimes) */
if (recognition) {
  recognition.onend = () => {
    if (micActive) {
      try { recognition.start(); } catch(e) {}
    }
  };

  recognition.onresult = (event) => {
    let t = "";
    for (let i = event.resultIndex; i < event.results.length; i++) {
      t += event.results[i][0].transcript;
    }
    sourceText.value = t.trim();
    doTranslate();
  };

  recognition.onerror = (e) => {
    console.error("Speech error", e);
  };
}

/* ==========================
   4. Type ‚Üí Auto Translate
========================== */
sourceText.addEventListener("input", () => {
  clearTimeout(window.debounceTimer);
  window.debounceTimer = setTimeout(doTranslate, 350);
});

/* ==========================
   5. Transliteration Helpers
========================== */
function toPinyin(text) {
  return text.normalize("NFD").replace(/[\u0300-\u036f]/g,"");
}
function toRomaji(text) {
  return text.replace(/shi/g,"shi").replace(/tsu/g,"tsu");
}
function koreanRomanize(text) {
  return text
    .replace(/eo/g,"≈è")
    .replace(/eu/g,"≈≠")
    .replace(/ui/g,"≈≠i");
}
function thaiRomanize(text) {
  return text
    .replace(/ph/g,"ph")
    .replace(/th/g,"th")
    .replace(/kh/g,"kh")
    .replace(/ng/g,"ng")
    .replace(/ch/g,"ch");
}

/* ==========================
   6. Google Translate Engine
========================== */
async function translateCore(text, sl, tl) {
  const url =
    "https://translate.googleapis.com/translate_a/single?client=gtx" +
    `&sl=${sl}&tl=en&dt=t&q=` + encodeURIComponent(text);

  const res = await fetch(url);
  if (!res.ok) return "";
  const data = await res.json();
  const english = data[0].map(a => a[0]).join("");

  if (tl === "zh-CN") return toPinyin(english);
  if (tl === "ja")    return toRomaji(english);
  if (tl === "ko")    return koreanRomanize(english);
  if (tl === "th")    return thaiRomanize(english);

  // Normal English / Filipino
  return english;
}

async function doTranslate() {
  const text = sourceText.value.trim();
  if (!text) {
    targetText.value = "";
    statusText.innerText = "Status: Idle";
    return;
  }

  statusText.innerText = "Status: Translating‚Ä¶";
  errorBox.textContent = "";

  const sl = sourceLang.value;
  const tl = targetLang.value;

  try {
    const translated = await translateCore(text, sl, tl);
    targetText.value = translated;
    statusText.innerText = "Status: Done.";
  } catch (e) {
    console.error(e);
    targetText.value = "";
    errorBox.textContent = e.message;
    statusText.innerText = "Status: Error.";
  }
}

/* ==========================
   7. Copy & Clear
========================== */
btnCopy.onclick = async () => {
  const txt = targetText.value.trim();
  if (!txt) return;
  try {
    await navigator.clipboard.writeText(txt);
    statusText.innerText = "Status: Copied.";
  } catch {
    statusText.innerText = "Status: Copy failed.";
  }
};

btnClear.onclick = () => {
  sourceText.value = "";
  targetText.value = "";
  errorBox.textContent = "";
  statusText.innerText = "Status: Idle";
};
</script>
</body>
</html>