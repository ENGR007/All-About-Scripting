<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Handwritten Notebook</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f3f3f3;
      color: #222;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    h1 {
      font-size: 1.4rem;
      margin: 5px 0 10px;
      text-align: center;
    }
    .app-container {
      width: 100%;
      max-width: 980px;
      background: #ffffff;
      border-radius: 10px;
      box-shadow: 0 4px 14px rgba(0,0,0,0.12);
      padding: 10px 10px 15px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      position: relative;
    }

    .fullscreen-topbar {
      display: none;
      text-align: center;
      font-size: 0.8rem;
      padding: 4px 6px;
      background: #333;
      color: #fff;
      border-radius: 6px;
      cursor: pointer;
    }

    .toolbar-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
    }
    .toolbar-group {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }
    .toolbar-label {
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      color: #555;
    }
    button, input, textarea, select {
      font-family: inherit;
    }
    button {
      border: 1px solid #ccc;
      background: #f8f8f8;
      border-radius: 5px;
      padding: 4px 8px;
      font-size: 0.85rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    button:hover {
      background: #ececec;
    }
    button.active {
      border-color: #0052cc;
      background: #e7f0ff;
    }
    .color-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid #999;
    }
    .color-black { background: #000; }
    .color-blue { background: #0052cc; }
    .color-red { background: #cc0000; }
    .color-yellow { background: #ffd54f; }

    .page-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      justify-content: space-between;
    }
    .page-info {
      font-size: 0.85rem;
      color: #555;
    }
    .page-title-input {
      flex: 1;
      min-width: 160px;
      padding: 4px 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.9rem;
    }

    .notebook-wrapper {
      margin-top: 4px;
      border-radius: 8px;
      border: 1px solid #ddd;
      overflow: hidden;
      background: #fdfcf8;
      position: relative;
      height: min(70vh, 640px); /* adapt to screen */
    }
    .page-surface {
      position: relative;
      width: 100%;
      height: 100%;
      background-image: 
        linear-gradient(to bottom, rgba(0,0,0,0.05) 1px, transparent 1px);
      background-size: 100% 24px;
      background-color: #fffbf3;
      padding-left: 40px; /* margin like a notebook */
    }
    .page-surface::before {
      /* vertical margin line */
      content: "";
      position: absolute;
      top: 0;
      bottom: 0;
      left: 30px;
      border-left: 2px solid rgba(255,0,0,0.35);
      pointer-events: none;
    }
    #drawingCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      touch-action: none; /* prevent scrolling during draw */
    }

    .note-meta {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 6px;
    }
    .note-meta label {
      font-size: 0.8rem;
      color: #666;
    }
    .note-meta textarea {
      width: 100%;
      min-height: 60px;
      resize: vertical;
      padding: 5px 6px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-size: 0.85rem;
    }

    .audio-section {
      margin-top: 6px;
      padding: 6px 4px;
      border-radius: 6px;
      border: 1px solid #eee;
      background: #fafafa;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .audio-section > label {
      font-size: 0.85rem;
      font-weight: 600;
      color: #555;
    }
    .audio-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }
    #recordStatus {
      font-size: 0.8rem;
      color: #444;
    }
    .audio-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .audio-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      font-size: 0.8rem;
    }
    .audio-row audio {
      max-width: 220px;
    }

    .search-row {
      margin-top: 4px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .search-input {
      width: 100%;
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-size: 0.85rem;
    }
    .search-results {
      max-height: 120px;
      overflow-y: auto;
      border-radius: 4px;
      border: 1px solid #eee;
      padding: 4px;
      font-size: 0.8rem;
    }
    .search-results button {
      width: 100%;
      justify-content: flex-start;
      margin-bottom: 2px;
      font-size: 0.8rem;
    }
    .hint {
      font-size: 0.75rem;
      color: #777;
    }

    .export-import-row {
      margin-top: 4px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      justify-content: flex-start;
    }

    .footer {
      margin-top: 6px;
      font-size: 0.75rem;
      text-align: center;
      color: #777;
    }

    /* Fullscreen (app-level) */
    .fullscreen .toolbar-row,
    .fullscreen .page-controls,
    .fullscreen .note-meta,
    .fullscreen .search-row,
    .fullscreen .export-import-row,
    .fullscreen .audio-section,
    .fullscreen .footer {
      display: none;
    }
    .fullscreen .fullscreen-topbar {
      display: block;
    }
    .fullscreen .notebook-wrapper {
      height: calc(100vh - 60px);
    }

    @media (max-width: 600px) {
      .toolbar-row,
      .page-controls {
        flex-direction: column;
        align-items: stretch;
      }
      button {
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <h1>Handwritten Notebook</h1>
  <div class="app-container">
    <div id="fullscreenTopBar" class="fullscreen-topbar">
      Tap here to show toolbar / exit full screen
    </div>

    <!-- Top toolbar: tools + pen size -->
    <div class="toolbar-row">
      <div class="toolbar-group">
        <span class="toolbar-label">Tools</span>
        <button id="toolPen" class="active">‚úèÔ∏è Pen</button>
        <button id="toolHighlighter">üñç Highlighter</button>
        <button id="toolEraser">ü©π Eraser</button>
        <button id="undoBtn">‚Ü∂ Undo</button>
        <button id="redoBtn">‚Ü∑ Redo</button>
        <button id="clearPageBtn">üóë Clear Page</button>
      </div>
      <div class="toolbar-group">
        <span class="toolbar-label">Pen</span>
        <button data-color="black" class="color-btn active">
          <span class="color-dot color-black"></span> Black
        </button>
        <button data-color="blue" class="color-btn">
          <span class="color-dot color-blue"></span> Blue
        </button>
        <button data-color="red" class="color-btn">
          <span class="color-dot color-red"></span> Red
        </button>
        <button data-color="yellow" class="color-btn">
          <span class="color-dot color-yellow"></span> Yellow
        </button>
        <label class="toolbar-label">Size
          <input id="sizeSlider" type="range" min="1" max="15" value="3" />
        </label>
      </div>
    </div>

    <!-- Page controls -->
    <div class="page-controls">
      <div class="toolbar-group">
        <button id="prevPageBtn">‚óÄ Prev</button>
        <button id="nextPageBtn">Next ‚ñ∂</button>
        <button id="addPageBtn">‚ûï Add Page</button>
        <span class="page-info" id="pageInfo">Page 1 / 1</span>
      </div>
      <div class="toolbar-group">
        <input id="pageTitle" class="page-title-input" placeholder="Page title (optional)" />
        <button id="fullscreenToggleBtn">Full Screen</button>
      </div>
    </div>

    <!-- Notebook page -->
    <div class="notebook-wrapper">
      <div class="page-surface">
        <canvas id="drawingCanvas"></canvas>
      </div>
    </div>

    <!-- Text notes (for searchability) -->
    <div class="note-meta">
      <label for="pageText">Typed notes / keywords for this page (used for search):</label>
      <textarea id="pageText" placeholder="Optional: summary, keywords, or typed notes here..."></textarea>
    </div>

    <!-- Audio notes -->
    <div class="audio-section">
      <label>Audio Notes (per page):</label>
      <div class="audio-controls">
        <button id="startRecordBtn">Start Recording</button>
        <button id="stopRecordBtn" disabled>Stop</button>
        <span id="recordStatus">Recording status: Idle</span>
      </div>
      <div id="audioList" class="audio-list"></div>
      <div id="audioHint" class="hint">
        üéô Audio recording uses your microphone. Support depends on your browser/device.
      </div>
    </div>

    <!-- Search section -->
    <div class="search-row">
      <label for="searchInput">Search pages (by title or typed notes):</label>
      <input id="searchInput" class="search-input" type="text" placeholder="Type to search..." />
      <div id="searchResults" class="search-results"></div>
      <div class="hint">
        üîç Search currently works on the page title and typed notes, not on handwritten strokes.
      </div>
    </div>

    <!-- Export / Import -->
    <div class="export-import-row">
      <button id="exportBtn">‚¨áÔ∏è Export Notebook</button>
      <button id="importBtn">‚¨ÜÔ∏è Import Notebook</button>
      <input id="importFile" type="file" accept="application/json" style="display:none" />
    </div>

    <div class="footer">
      Notebook is stored locally in this browser using localStorage. You can close and reopen and continue where you left off.  
      Use Export/Import to back up or move to another browser.
    </div>
  </div>

  <script>
    // ---- Data model ----
    const STORAGE_KEY = "handNotebook_v2";

    let pages = [];
    let currentPageIndex = 0;

    const canvas = document.getElementById("drawingCanvas");
    const ctx = canvas.getContext("2d");

    let isDrawing = false;
    let currentStroke = null;

    const toolButtons = {
      pen: document.getElementById("toolPen"),
      highlighter: document.getElementById("toolHighlighter"),
      eraser: document.getElementById("toolEraser")
    };
    let currentTool = "pen";

    const sizeSlider = document.getElementById("sizeSlider");
    let currentSize = parseInt(sizeSlider.value, 10);

    let currentColor = "black";

    // Audio state
    let mediaRecorder = null;
    let recordedChunks = [];
    let currentStream = null;
    let isRecordingAudio = false;
    const audioSupported = !!(navigator.mediaDevices && window.MediaRecorder);

    const startRecordBtn = document.getElementById("startRecordBtn");
    const stopRecordBtn = document.getElementById("stopRecordBtn");
    const recordStatus = document.getElementById("recordStatus");
    const audioListEl = document.getElementById("audioList");
    const audioHintEl = document.getElementById("audioHint");

    // Fullscreen state
    const appContainer = document.querySelector(".app-container");
    const fullscreenTopBar = document.getElementById("fullscreenTopBar");
    const fullscreenToggleBtn = document.getElementById("fullscreenToggleBtn");
    let isFullscreenMode = false;

    // ---- Helpers for notebook pages ----
    function createBlankPage() {
      return {
        id: Date.now() + Math.random(),
        title: "",
        text: "",
        strokes: [],
        undoStack: [],
        redoStack: [],
        audio: [] // {id, dataUrl, name}
      };
    }

    function saveNotebook() {
      const data = {
        pages,
        currentPageIndex
      };
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      } catch (e) {
        console.warn("Could not save notebook:", e);
      }
    }

    function loadNotebook() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) {
        pages = [createBlankPage()];
        currentPageIndex = 0;
        return;
      }
      try {
        const parsed = JSON.parse(raw);
        pages = (parsed.pages || []).map(p => ({
          ...createBlankPage(),
          ...p,
          audio: p.audio || []
        }));
        if (!pages.length) {
          pages = [createBlankPage()];
        }
        currentPageIndex = Math.min(
          parsed.currentPageIndex || 0,
          pages.length - 1
        );
      } catch (e) {
        console.warn("Could not load notebook:", e);
        pages = [createBlankPage()];
        currentPageIndex = 0;
      }
    }

    function updatePageInfo() {
      const info = document.getElementById("pageInfo");
      info.textContent = `Page ${currentPageIndex + 1} / ${pages.length}`;
    }

    function resizeCanvasToContainer() {
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      redrawCurrentPage();
    }

    window.addEventListener("resize", () => {
      resizeCanvasToContainer();
    });

    // ---- Drawing logic ----
    function startStroke(x, y) {
      const page = pages[currentPageIndex];
      page.redoStack = []; // new stroke invalidates redo history

      const normalizedPoint = normalizePoint(x, y);
      const stroke = {
        tool: currentTool, // 'pen', 'highlighter', 'eraser'
        color: currentColor,
        size: currentSize,
        points: [normalizedPoint]
      };
      currentStroke = stroke;
      page.strokes.push(stroke);
      isDrawing = true;
      redrawCurrentPage();
    }

    function addPointToStroke(x, y) {
      if (!isDrawing || !currentStroke) return;
      currentStroke.points.push(normalizePoint(x, y));
      redrawCurrentPage();
    }

    function endStroke() {
      if (!isDrawing) return;
      isDrawing = false;
      const page = pages[currentPageIndex];
      if (currentStroke && currentStroke.points.length > 0) {
        page.undoStack.push(currentStroke);
      }
      currentStroke = null;
      saveNotebook();
    }

    function normalizePoint(x, y) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: x / rect.width,
        y: y / rect.height
      };
    }

    function denormalizePoint(p) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: p.x * rect.width,
        y: p.y * rect.height
      };
    }

    function redrawCurrentPage() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const page = pages[currentPageIndex];
      if (!page) return;

      for (const stroke of page.strokes) {
        drawStroke(stroke);
      }
    }

    function drawStroke(stroke) {
      if (!stroke.points || stroke.points.length < 1) return;

      if (stroke.tool === "eraser") {
        ctx.globalCompositeOperation = "destination-out";
        ctx.lineWidth = stroke.size * 3; // thicker erase
        ctx.strokeStyle = "rgba(0,0,0,1)";
      } else if (stroke.tool === "highlighter") {
        ctx.globalCompositeOperation = "source-over";
        ctx.lineWidth = stroke.size * 3;
        // highlighter is always yellowish
        ctx.strokeStyle = "rgba(255, 235, 59, 0.45)";
      } else {
        ctx.globalCompositeOperation = "source-over";
        ctx.lineWidth = stroke.size * 2; // make pen clearer
        ctx.strokeStyle = getColorValue(stroke.color || "black");
      }

      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      ctx.beginPath();
      const first = denormalizePoint(stroke.points[0]);
      ctx.moveTo(first.x, first.y);
      for (let i = 1; i < stroke.points.length; i++) {
        const p = denormalizePoint(stroke.points[i]);
        ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
    }

    function getColorValue(name) {
      switch (name) {
        case "blue": return "#0052cc";
        case "red": return "#cc0000";
        case "yellow": return "#ffd54f";
        case "black":
        default:
          return "#000000";
      }
    }

    // ---- Undo / Redo / Clear ----
    function undo() {
      const page = pages[currentPageIndex];
      if (!page || page.strokes.length === 0) return;
      const stroke = page.strokes.pop();
      page.redoStack.push(stroke);
      redrawCurrentPage();
      saveNotebook();
    }

    function redo() {
      const page = pages[currentPageIndex];
      if (!page || page.redoStack.length === 0) return;
      const stroke = page.redoStack.pop();
      page.strokes.push(stroke);
      page.undoStack.push(stroke);
      redrawCurrentPage();
      saveNotebook();
    }

    function clearPage() {
      if (!confirm("Clear this entire page? This cannot be undone.")) return;
      const page = pages[currentPageIndex];
      page.strokes = [];
      page.undoStack = [];
      page.redoStack = [];
      redrawCurrentPage();
      saveNotebook();
    }

    // ---- Page navigation ----
    function goToPage(index) {
      if (index < 0 || index >= pages.length) return;
      currentPageIndex = index;
      const page = pages[currentPageIndex];
      document.getElementById("pageTitle").value = page.title || "";
      document.getElementById("pageText").value = page.text || "";
      updatePageInfo();
      resizeCanvasToContainer(); // this will also redraw
      renderAudioList();
      saveNotebook();
    }

    function addPage() {
      const newPage = createBlankPage();
      pages.push(newPage);
      goToPage(pages.length - 1);
    }

    // ---- Search ----
    function performSearch(query) {
      const resultsContainer = document.getElementById("searchResults");
      resultsContainer.innerHTML = "";
      const q = query.trim().toLowerCase();
      if (!q) return;

      pages.forEach((page, idx) => {
        const haystack = ((page.title || "") + " " + (page.text || "")).toLowerCase();
        if (haystack.includes(q)) {
          const btn = document.createElement("button");
          const title = page.title || `Untitled page ${idx + 1}`;
          btn.textContent = `Page ${idx + 1}: ${title}`;
          btn.addEventListener("click", () => {
            goToPage(idx);
          });
          resultsContainer.appendChild(btn);
        }
      });

      if (!resultsContainer.children.length) {
        resultsContainer.textContent = "No matches found.";
      }
    }

    // ---- UI setup ----
    function setActiveTool(tool) {
      currentTool = tool;
      Object.values(toolButtons).forEach(btn => btn.classList.remove("active"));
      if (tool === "pen") toolButtons.pen.classList.add("active");
      if (tool === "highlighter") toolButtons.highlighter.classList.add("active");
      if (tool === "eraser") toolButtons.eraser.classList.add("active");
    }

    function setActiveColor(color) {
      currentColor = color;
      document.querySelectorAll(".color-btn").forEach(btn => {
        btn.classList.toggle("active", btn.dataset.color === color);
      });
    }

    // ---- Pointer events ----
    function getCanvasCoordinates(evt) {
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      return { x, y };
    }

    canvas.addEventListener("pointerdown", (evt) => {
      evt.preventDefault();
      canvas.setPointerCapture(evt.pointerId);
      const { x, y } = getCanvasCoordinates(evt);
      startStroke(x, y);
    });

    canvas.addEventListener("pointermove", (evt) => {
      if (!isDrawing) return;
      evt.preventDefault();
      const { x, y } = getCanvasCoordinates(evt);
      addPointToStroke(x, y);
    });

    canvas.addEventListener("pointerup", (evt) => {
      evt.preventDefault();
      canvas.releasePointerCapture(evt.pointerId);
      endStroke();
    });

    canvas.addEventListener("pointerleave", () => {
      if (isDrawing) {
        endStroke();
      }
    });

    // ---- Audio helpers ----
    function dataUrlToBlob(dataUrl) {
      const parts = dataUrl.split(",");
      const match = parts[0].match(/:(.*?);/);
      const mime = match ? match[1] : "audio/webm";
      const binary = atob(parts[1]);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return new Blob([bytes], { type: mime });
    }

    function renderAudioList() {
      const page = pages[currentPageIndex];
      audioListEl.innerHTML = "";
      if (!page || !page.audio || !page.audio.length) {
        audioListEl.textContent = "No audio notes on this page yet.";
        return;
      }
      page.audio.forEach((clip, idx) => {
        const row = document.createElement("div");
        row.className = "audio-row";

        const audioEl = document.createElement("audio");
        audioEl.controls = true;
        try {
          const blob = dataUrlToBlob(clip.dataUrl);
          audioEl.src = URL.createObjectURL(blob);
        } catch (e) {
          audioEl.textContent = "Audio not supported.";
        }

        const labelSpan = document.createElement("span");
        labelSpan.textContent = clip.name || `Audio ${idx + 1}`;

        const delBtn = document.createElement("button");
        delBtn.textContent = "Delete";
        delBtn.addEventListener("click", () => {
          if (!confirm("Delete this audio note?")) return;
          page.audio.splice(idx, 1);
          saveNotebook();
          renderAudioList();
        });

        row.appendChild(audioEl);
        row.appendChild(labelSpan);
        row.appendChild(delBtn);
        audioListEl.appendChild(row);
      });
    }

    async function startRecording() {
      if (!audioSupported || isRecordingAudio) return;
      try {
        const constraints = { audio: true };
        currentStream = await navigator.mediaDevices.getUserMedia(constraints);

        let options = {};
        if (window.MediaRecorder && MediaRecorder.isTypeSupported) {
          if (MediaRecorder.isTypeSupported("audio/mp4")) {
            options.mimeType = "audio/mp4";
          } else if (MediaRecorder.isTypeSupported("audio/webm")) {
            options.mimeType = "audio/webm";
          }
        }

        mediaRecorder = new MediaRecorder(currentStream, options);
        recordedChunks = [];

        mediaRecorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) {
            recordedChunks.push(e.data);
          }
        };

        mediaRecorder.onstop = () => {
          isRecordingAudio = false;
          startRecordBtn.disabled = false;
          stopRecordBtn.disabled = true;

          if (currentStream) {
            currentStream.getTracks().forEach(t => t.stop());
            currentStream = null;
          }

          if (!recordedChunks.length) {
            recordStatus.textContent = "Recording status: No audio captured.";
            return;
          }

          const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType || "audio/webm" });
          const reader = new FileReader();
          reader.onloadend = () => {
            const dataUrl = reader.result;
            const page = pages[currentPageIndex];
            if (!page.audio) page.audio = [];
            const name = `Audio ${page.audio.length + 1} (${new Date().toLocaleTimeString()})`;
            page.audio.push({
              id: Date.now(),
              dataUrl,
              name
            });
            saveNotebook();
            renderAudioList();
            recordStatus.textContent = "Recording status: Saved.";
          };
          reader.readAsDataURL(blob);
        };

        mediaRecorder.start();
        isRecordingAudio = true;
        startRecordBtn.disabled = true;
        stopRecordBtn.disabled = false;
        recordStatus.textContent = "Recording status: Recording...";
      } catch (e) {
        console.error(e);
        recordStatus.textContent = "Recording status: Permission denied or error.";
      }
    }

    function stopRecording() {
      if (!isRecordingAudio || !mediaRecorder) return;
      recordStatus.textContent = "Recording status: Stopping...";
      mediaRecorder.stop();
    }

    function initAudio() {
      if (!audioSupported) {
        startRecordBtn.disabled = true;
        stopRecordBtn.disabled = true;
        recordStatus.textContent = "Recording status: Not supported in this browser.";
        audioHintEl.textContent = "Your browser does not support in-page audio recording.";
        return;
      }

      startRecordBtn.addEventListener("click", startRecording);
      stopRecordBtn.addEventListener("click", stopRecording);
    }

    // ---- Export / Import ----
    const exportBtn = document.getElementById("exportBtn");
    const importBtn = document.getElementById("importBtn");
    const importFileInput = document.getElementById("importFile");

    exportBtn.addEventListener("click", () => {
      const dataStr = JSON.stringify({ pages, currentPageIndex });
      const blob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      const dateStr = new Date().toISOString().slice(0, 10);
      a.download = `handwritten_notebook_${dateStr}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    importBtn.addEventListener("click", () => {
      importFileInput.click();
    });

    importFileInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        try {
          const data = JSON.parse(ev.target.result);
          if (!data.pages || !Array.isArray(data.pages)) {
            throw new Error("Invalid notebook format");
          }
          pages = data.pages.map(p => ({
            ...createBlankPage(),
            ...p,
            audio: p.audio || []
          }));
          if (!pages.length) pages = [createBlankPage()];
          currentPageIndex = Math.min(data.currentPageIndex || 0, pages.length - 1);
          goToPage(currentPageIndex);
          updatePageInfo();
          saveNotebook();
          alert("Notebook imported successfully.");
        } catch (err) {
          console.error(err);
          alert("Could not import file. It may not be a valid notebook backup.");
        } finally {
          importFileInput.value = "";
        }
      };
      reader.readAsText(file);
    });

    // ---- Fullscreen (app-level) ----
    function enterFullscreen() {
      isFullscreenMode = true;
      appContainer.classList.add("fullscreen");
      fullscreenToggleBtn.textContent = "Exit Full Screen";
      resizeCanvasToContainer();
    }

    function exitFullscreen() {
      isFullscreenMode = false;
      appContainer.classList.remove("fullscreen");
      fullscreenToggleBtn.textContent = "Full Screen";
      resizeCanvasToContainer();
    }

    fullscreenToggleBtn.addEventListener("click", () => {
      if (isFullscreenMode) {
        exitFullscreen();
      } else {
        enterFullscreen();
      }
    });

    fullscreenTopBar.addEventListener("click", () => {
      if (isFullscreenMode) {
        exitFullscreen();
      }
    });

    // ---- Wire up controls ----
    document.getElementById("undoBtn").addEventListener("click", undo);
    document.getElementById("redoBtn").addEventListener("click", redo);
    document.getElementById("clearPageBtn").addEventListener("click", clearPage);

    toolButtons.pen.addEventListener("click", () => setActiveTool("pen"));
    toolButtons.highlighter.addEventListener("click", () => setActiveTool("highlighter"));
    toolButtons.eraser.addEventListener("click", () => setActiveTool("eraser"));

    document.querySelectorAll(".color-btn").forEach(btn => {
      btn.addEventListener("click", () => setActiveColor(btn.dataset.color));
    });

    sizeSlider.addEventListener("input", () => {
      currentSize = parseInt(sizeSlider.value, 10);
    });

    document.getElementById("prevPageBtn").addEventListener("click", () => {
      if (currentPageIndex > 0) goToPage(currentPageIndex - 1);
    });
    document.getElementById("nextPageBtn").addEventListener("click", () => {
      if (currentPageIndex < pages.length - 1) goToPage(currentPageIndex + 1);
    });
    document.getElementById("addPageBtn").addEventListener("click", addPage);

    document.getElementById("pageTitle").addEventListener("input", (e) => {
      const page = pages[currentPageIndex];
      page.title = e.target.value;
      saveNotebook();
    });

    document.getElementById("pageText").addEventListener("input", (e) => {
      const page = pages[currentPageIndex];
      page.text = e.target.value;
      saveNotebook();
    });

    document.getElementById("searchInput").addEventListener("input", (e) => {
      performSearch(e.target.value);
    });

    // ---- Init ----
    loadNotebook();
    updatePageInfo();
    document.getElementById("pageTitle").value = pages[currentPageIndex].title || "";
    document.getElementById("pageText").value = pages[currentPageIndex].text || "";
    resizeCanvasToContainer();
    setActiveTool(currentTool);
    setActiveColor(currentColor);
    renderAudioList();
    initAudio();
  </script>
</body>
</html>