<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Handwritten Notebook</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f3f3f3;
      color: #222;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    h1 {
      font-size: 1.4rem;
      margin: 5px 0 10px;
      text-align: center;
    }
    .app-container {
      width: 100%;
      max-width: 980px;
      background: #ffffff;
      border-radius: 10px;
      box-shadow: 0 4px 14px rgba(0,0,0,0.12);
      padding: 10px 10px 15px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .toolbar-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
    }
    .toolbar-group {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }
    .toolbar-label {
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      color: #555;
    }
    button, input, textarea, select {
      font-family: inherit;
    }
    button {
      border: 1px solid #ccc;
      background: #f8f8f8;
      border-radius: 5px;
      padding: 4px 8px;
      font-size: 0.85rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    button:hover {
      background: #ececec;
    }
    button.active {
      border-color: #0052cc;
      background: #e7f0ff;
    }
    .color-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid #999;
    }
    .color-black { background: #000; }
    .color-blue { background: #0052cc; }
    .color-red { background: #cc0000; }
    .color-yellow { background: #ffd54f; }

    .page-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      justify-content: space-between;
    }
    .page-info {
      font-size: 0.85rem;
      color: #555;
    }
    .page-title-input {
      flex: 1;
      min-width: 160px;
      padding: 4px 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.9rem;
    }

    .notebook-wrapper {
      margin-top: 4px;
      border-radius: 8px;
      border: 1px solid #ddd;
      overflow: hidden;
      background: #fdfcf8;
      position: relative;
      height: min(70vh, 640px); /* adapt to screen */
    }
    .page-surface {
      position: relative;
      width: 100%;
      height: 100%;
      background-image: 
        linear-gradient(to bottom, rgba(0,0,0,0.05) 1px, transparent 1px);
      background-size: 100% 24px;
      background-color: #fffbf3;
      padding-left: 40px; /* margin like a notebook */
    }
    .page-surface::before {
      /* vertical margin line */
      content: "";
      position: absolute;
      top: 0;
      bottom: 0;
      left: 30px;
      border-left: 2px solid rgba(255,0,0,0.35);
      pointer-events: none;
    }
    #drawingCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      touch-action: none; /* prevent scrolling during draw */
    }

    .note-meta {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 6px;
    }
    .note-meta label {
      font-size: 0.8rem;
      color: #666;
    }
    .note-meta textarea {
      width: 100%;
      min-height: 60px;
      resize: vertical;
      padding: 5px 6px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-size: 0.85rem;
    }

    .search-row {
      margin-top: 4px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .search-input {
      width: 100%;
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-size: 0.85rem;
    }
    .search-results {
      max-height: 120px;
      overflow-y: auto;
      border-radius: 4px;
      border: 1px solid #eee;
      padding: 4px;
      font-size: 0.8rem;
    }
    .search-results button {
      width: 100%;
      justify-content: flex-start;
      margin-bottom: 2px;
      font-size: 0.8rem;
    }
    .hint {
      font-size: 0.75rem;
      color: #777;
    }

    .footer {
      margin-top: 6px;
      font-size: 0.75rem;
      text-align: center;
      color: #777;
    }

    @media (max-width: 600px) {
      .toolbar-row,
      .page-controls {
        flex-direction: column;
        align-items: stretch;
      }
      button {
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <h1>Handwritten Notebook</h1>
  <div class="app-container">
    <!-- Top toolbar: tools + pen size -->
    <div class="toolbar-row">
      <div class="toolbar-group">
        <span class="toolbar-label">Tools</span>
        <button id="toolPen" class="active">‚úèÔ∏è Pen</button>
        <button id="toolHighlighter">üñç Highlighter</button>
        <button id="toolEraser">ü©π Eraser</button>
        <button id="undoBtn">‚Ü∂ Undo</button>
        <button id="redoBtn">‚Ü∑ Redo</button>
        <button id="clearPageBtn">üóë Clear Page</button>
      </div>
      <div class="toolbar-group">
        <span class="toolbar-label">Pen</span>
        <button data-color="black" class="color-btn active">
          <span class="color-dot color-black"></span> Black
        </button>
        <button data-color="blue" class="color-btn">
          <span class="color-dot color-blue"></span> Blue
        </button>
        <button data-color="red" class="color-btn">
          <span class="color-dot color-red"></span> Red
        </button>
        <button data-color="yellow" class="color-btn">
          <span class="color-dot color-yellow"></span> Highlight
        </button>
        <label class="toolbar-label">Size
          <input id="sizeSlider" type="range" min="1" max="15" value="3" />
        </label>
      </div>
    </div>

    <!-- Page controls -->
    <div class="page-controls">
      <div class="toolbar-group">
        <button id="prevPageBtn">‚óÄ Prev</button>
        <button id="nextPageBtn">Next ‚ñ∂</button>
        <button id="addPageBtn">‚ûï Add Page</button>
        <span class="page-info" id="pageInfo">Page 1 / 1</span>
      </div>
      <input id="pageTitle" class="page-title-input" placeholder="Page title (optional)" />
    </div>

    <!-- Notebook page -->
    <div class="notebook-wrapper">
      <div class="page-surface">
        <canvas id="drawingCanvas"></canvas>
      </div>
    </div>

    <!-- Text notes (for searchability) -->
    <div class="note-meta">
      <label for="pageText">Typed notes / keywords for this page (used for search):</label>
      <textarea id="pageText" placeholder="Optional: summary, keywords, or typed notes here..."></textarea>
    </div>

    <!-- Search section -->
    <div class="search-row">
      <label for="searchInput">Search pages (by title or typed notes):</label>
      <input id="searchInput" class="search-input" type="text" placeholder="Type to search..." />
      <div id="searchResults" class="search-results"></div>
      <div class="hint">
        üîç Search currently works on the page title and typed notes, not on handwritten strokes.
      </div>
    </div>

    <div class="footer">
      Notebook is stored locally in this browser using localStorage. You can close and reopen and continue where you left off.
    </div>
  </div>

  <script>
    // ---- Data model ----
    const STORAGE_KEY = "handNotebook_v1";

    let pages = [];
    let currentPageIndex = 0;

    const canvas = document.getElementById("drawingCanvas");
    const ctx = canvas.getContext("2d");

    let isDrawing = false;
    let currentStroke = null;

    const toolButtons = {
      pen: document.getElementById("toolPen"),
      highlighter: document.getElementById("toolHighlighter"),
      eraser: document.getElementById("toolEraser")
    };
    let currentTool = "pen";

    const sizeSlider = document.getElementById("sizeSlider");
    let currentSize = parseInt(sizeSlider.value, 10);

    let currentColor = "black";

    // ---- Helpers for notebook pages ----
    function createBlankPage() {
      return {
        id: Date.now() + Math.random(),
        title: "",
        text: "",
        strokes: [],
        undoStack: [],
        redoStack: []
      };
    }

    function saveNotebook() {
      const data = {
        pages,
        currentPageIndex
      };
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      } catch (e) {
        console.warn("Could not save notebook:", e);
      }
    }

    function loadNotebook() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) {
        pages = [createBlankPage()];
        currentPageIndex = 0;
        return;
      }
      try {
        const parsed = JSON.parse(raw);
        pages = parsed.pages || [createBlankPage()];
        currentPageIndex = Math.min(
          parsed.currentPageIndex || 0,
          pages.length - 1
        );
      } catch (e) {
        console.warn("Could not load notebook:", e);
        pages = [createBlankPage()];
        currentPageIndex = 0;
      }
    }

    function updatePageInfo() {
      const info = document.getElementById("pageInfo");
      info.textContent = `Page ${currentPageIndex + 1} / ${pages.length}`;
    }

    function resizeCanvasToContainer() {
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      redrawCurrentPage();
    }

    window.addEventListener("resize", () => {
      resizeCanvasToContainer();
    });

    // ---- Drawing logic ----
    function startStroke(x, y) {
      const page = pages[currentPageIndex];
      page.redoStack = []; // new stroke invalidates redo history

      const normalizedPoint = normalizePoint(x, y);
      const stroke = {
        tool: currentTool, // 'pen', 'highlighter', 'eraser'
        color: currentColor,
        size: currentSize,
        points: [normalizedPoint]
      };
      currentStroke = stroke;
      page.strokes.push(stroke);
      isDrawing = true;
      redrawCurrentPage();
    }

    function addPointToStroke(x, y) {
      if (!isDrawing || !currentStroke) return;
      currentStroke.points.push(normalizePoint(x, y));
      redrawCurrentPage();
    }

    function endStroke() {
      if (!isDrawing) return;
      isDrawing = false;
      const page = pages[currentPageIndex];
      if (currentStroke && currentStroke.points.length > 0) {
        page.undoStack.push(currentStroke);
      }
      currentStroke = null;
      saveNotebook();
    }

    function normalizePoint(x, y) {
      return {
        x: x / canvas.width,
        y: y / canvas.height
      };
    }

    function denormalizePoint(p) {
      return {
        x: p.x * canvas.width,
        y: p.y * canvas.height
      };
    }

    function redrawCurrentPage() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const page = pages[currentPageIndex];
      if (!page) return;

      for (const stroke of page.strokes) {
        drawStroke(stroke);
      }
    }

    function drawStroke(stroke) {
      if (!stroke.points || stroke.points.length < 1) return;

      if (stroke.tool === "eraser") {
        ctx.globalCompositeOperation = "destination-out";
        ctx.lineWidth = stroke.size * 2;
        ctx.strokeStyle = "rgba(0,0,0,1)";
      } else if (stroke.tool === "highlighter") {
        ctx.globalCompositeOperation = "source-over";
        ctx.lineWidth = stroke.size * 2;
        // highlighter is always yellowish
        ctx.strokeStyle = "rgba(255, 235, 59, 0.45)";
      } else {
        ctx.globalCompositeOperation = "source-over";
        ctx.lineWidth = stroke.size;
        ctx.strokeStyle = getColorValue(stroke.color || "black");
      }

      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      ctx.beginPath();
      const first = denormalizePoint(stroke.points[0]);
      ctx.moveTo(first.x, first.y);
      for (let i = 1; i < stroke.points.length; i++) {
        const p = denormalizePoint(stroke.points[i]);
        ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
    }

    function getColorValue(name) {
      switch (name) {
        case "blue": return "#0052cc";
        case "red": return "#cc0000";
        case "yellow": return "#ffd54f";
        case "black":
        default:
          return "#000000";
      }
    }

    // ---- Undo / Redo / Clear ----
    function undo() {
      const page = pages[currentPageIndex];
      if (!page || page.strokes.length === 0) return;
      const stroke = page.strokes.pop();
      page.redoStack.push(stroke);
      redrawCurrentPage();
      saveNotebook();
    }

    function redo() {
      const page = pages[currentPageIndex];
      if (!page || page.redoStack.length === 0) return;
      const stroke = page.redoStack.pop();
      page.strokes.push(stroke);
      page.undoStack.push(stroke);
      redrawCurrentPage();
      saveNotebook();
    }

    function clearPage() {
      if (!confirm("Clear this entire page? This cannot be undone.")) return;
      const page = pages[currentPageIndex];
      page.strokes = [];
      page.undoStack = [];
      page.redoStack = [];
      redrawCurrentPage();
      saveNotebook();
    }

    // ---- Page navigation ----
    function goToPage(index) {
      if (index < 0 || index >= pages.length) return;
      currentPageIndex = index;
      const page = pages[currentPageIndex];
      document.getElementById("pageTitle").value = page.title || "";
      document.getElementById("pageText").value = page.text || "";
      updatePageInfo();
      resizeCanvasToContainer(); // this will also redraw
      saveNotebook();
    }

    function addPage() {
      const newPage = createBlankPage();
      pages.push(newPage);
      goToPage(pages.length - 1);
    }

    // ---- Search ----
    function performSearch(query) {
      const resultsContainer = document.getElementById("searchResults");
      resultsContainer.innerHTML = "";
      const q = query.trim().toLowerCase();
      if (!q) return;

      pages.forEach((page, idx) => {
        const haystack = ((page.title || "") + " " + (page.text || "")).toLowerCase();
        if (haystack.includes(q)) {
          const btn = document.createElement("button");
          const title = page.title || `Untitled page ${idx + 1}`;
          btn.textContent = `Page ${idx + 1}: ${title}`;
          btn.addEventListener("click", () => {
            goToPage(idx);
          });
          resultsContainer.appendChild(btn);
        }
      });

      if (!resultsContainer.children.length) {
        resultsContainer.textContent = "No matches found.";
      }
    }

    // ---- UI setup ----
    function setActiveTool(tool) {
      currentTool = tool;
      Object.values(toolButtons).forEach(btn => btn.classList.remove("active"));
      if (tool === "pen") toolButtons.pen.classList.add("active");
      if (tool === "highlighter") toolButtons.highlighter.classList.add("active");
      if (tool === "eraser") toolButtons.eraser.classList.add("active");
    }

    function setActiveColor(color) {
      currentColor = color;
      document.querySelectorAll(".color-btn").forEach(btn => {
        btn.classList.toggle("active", btn.dataset.color === color);
      });
    }

    // ---- Pointer events ----
    function getCanvasCoordinates(evt) {
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      return { x, y };
    }

    canvas.addEventListener("pointerdown", (evt) => {
      evt.preventDefault();
      canvas.setPointerCapture(evt.pointerId);
      const { x, y } = getCanvasCoordinates(evt);
      startStroke(x, y);
    });

    canvas.addEventListener("pointermove", (evt) => {
      if (!isDrawing) return;
      evt.preventDefault();
      const { x, y } = getCanvasCoordinates(evt);
      addPointToStroke(x, y);
    });

    canvas.addEventListener("pointerup", (evt) => {
      evt.preventDefault();
      canvas.releasePointerCapture(evt.pointerId);
      endStroke();
    });

    canvas.addEventListener("pointerleave", (evt) => {
      if (isDrawing) {
        endStroke();
      }
    });

    // ---- Wire up controls ----
    document.getElementById("undoBtn").addEventListener("click", undo);
    document.getElementById("redoBtn").addEventListener("click", redo);
    document.getElementById("clearPageBtn").addEventListener("click", clearPage);

    toolButtons.pen.addEventListener("click", () => setActiveTool("pen"));
    toolButtons.highlighter.addEventListener("click", () => setActiveTool("highlighter"));
    toolButtons.eraser.addEventListener("click", () => setActiveTool("eraser"));

    document.querySelectorAll(".color-btn").forEach(btn => {
      btn.addEventListener("click", () => setActiveColor(btn.dataset.color));
    });

    sizeSlider.addEventListener("input", () => {
      currentSize = parseInt(sizeSlider.value, 10);
    });

    document.getElementById("prevPageBtn").addEventListener("click", () => {
      if (currentPageIndex > 0) goToPage(currentPageIndex - 1);
    });
    document.getElementById("nextPageBtn").addEventListener("click", () => {
      if (currentPageIndex < pages.length - 1) goToPage(currentPageIndex + 1);
    });
    document.getElementById("addPageBtn").addEventListener("click", addPage);

    document.getElementById("pageTitle").addEventListener("input", (e) => {
      const page = pages[currentPageIndex];
      page.title = e.target.value;
      saveNotebook();
    });

    document.getElementById("pageText").addEventListener("input", (e) => {
      const page = pages[currentPageIndex];
      page.text = e.target.value;
      saveNotebook();
    });

    document.getElementById("searchInput").addEventListener("input", (e) => {
      performSearch(e.target.value);
    });

    // ---- Init ----
    loadNotebook();
    updatePageInfo();
    // Fill title & text for current page
    document.getElementById("pageTitle").value = pages[currentPageIndex].title || "";
    document.getElementById("pageText").value = pages[currentPageIndex].text || "";
    // Must size canvas after DOM is ready
    resizeCanvasToContainer();
  </script>
</body>
</html>