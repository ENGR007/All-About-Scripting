<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Handwritten Notebook</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f3f3f3;
      color: #222;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    h1 {
      font-size: 1.4rem;
      margin: 5px 0 10px;
      text-align: center;
    }
    .app-container {
      width: 100%;
      max-width: 980px;
      background: #ffffff;
      border-radius: 10px;
      box-shadow: 0 4px 14px rgba(0,0,0,0.12);
      padding: 10px 10px 15px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      position: relative;
    }

    .fullscreen-topbar {
      display: none;
      text-align: center;
      font-size: 0.8rem;
      padding: 4px 6px;
      background: #333;
      color: #fff;
      border-radius: 6px;
      cursor: pointer;
    }

    /* Notebook bar */
    .notebook-bar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-bottom: 4px;
    }
    .notebook-select {
      min-width: 160px;
      padding: 3px 6px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-size: 0.85rem;
    }
    .notebook-small-btn {
      padding: 2px 6px;
      font-size: 0.75rem;
    }

    .toolbar-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: center; /* centered Tools + Pen */
    }
    .toolbar-group {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }
    .toolbar-label {
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      color: #555;
    }
    button, input, textarea, select {
      font-family: inherit;
    }
    button {
      border: 1px solid #ccc;
      background: #f8f8f8;
      border-radius: 5px;
      padding: 4px 8px;
      font-size: 0.85rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    button:hover {
      background: #ececec;
    }
    button.active {
      border-color: #0052cc;
      background: #e7f0ff;
    }
    .color-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid #999;
    }
    .color-black { background: #000; }
    .color-blue { background: #0052cc; }
    .color-red { background: #cc0000; }
    .color-yellow { background: #ffd54f; }

    .page-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      justify-content: space-between;
    }
    .page-info {
      font-size: 0.85rem;
      color: #555;
    }
    .page-title-input {
      flex: 1;
      min-width: 160px;
      padding: 4px 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.9rem;
    }

    .notebook-wrapper {
      margin-top: 4px;
      border-radius: 8px;
      border: 1px solid #ddd;
      overflow: hidden;
      background: #fffbf3;
      position: relative;
      height: min(70vh, 640px); /* adapt to screen */
      -webkit-user-select: none;
      user-select: none;
    }
    .page-surface {
      position: relative;
      width: 100%;
      height: 100%;
      background-image:
        linear-gradient(to bottom, rgba(0,0,0,0.05) 1px, transparent 1px);
      background-size: 100% 24px;
      background-color: #fffbf3;
      padding-left: 40px; /* margin like a notebook */
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }
    .page-surface::before {
      /* vertical margin line */
      content: "";
      position: absolute;
      top: 0;
      bottom: 0;
      left: 30px;
      border-left: 2px solid rgba(255,0,0,0.35);
      pointer-events: none;
    }
    #drawingCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      touch-action: none; /* prevent scrolling during draw */
      -webkit-user-select: none;
      user-select: none;
    }

    .note-meta {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 6px;
    }
    .note-meta label {
      font-size: 0.8rem;
      color: #666;
    }
    .note-meta textarea {
      width: 100%;
      min-height: 60px;
      resize: vertical;
      padding: 5px 6px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-size: 0.85rem;
    }

    .audio-section {
      margin-top: 6px;
      padding: 6px 4px;
      border-radius: 6px;
      border: 1px solid #eee;
      background: #fafafa;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .audio-section > label {
      font-size: 0.85rem;
      font-weight: 600;
      color: #555;
    }
    .audio-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }
    #recordStatus {
      font-size: 0.8rem;
      color: #444;
    }
    .audio-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .audio-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      font-size: 0.8rem;
    }
    .audio-row audio {
      max-width: 220px;
    }

    /* Transcript area */
    #liveTranscript,
    #finalTranscript {
      width: 100%;
      min-height: 80px;
      resize: vertical;
      padding: 5px 6px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-size: 0.85rem;
    }

    .search-row {
      margin-top: 4px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .search-input {
      width: 100%;
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-size: 0.85rem;
    }
    .search-results {
      max-height: 120px;
      overflow-y: auto;
      border-radius: 4px;
      border: 1px solid #eee;
      padding: 4px;
      font-size: 0.8rem;
    }
    .search-results button {
      width: 100%;
      justify-content: flex-start;
      margin-bottom: 2px;
      font-size: 0.8rem;
    }
    .hint {
      font-size: 0.75rem;
      color: #777;
    }

    .export-import-row {
      margin-top: 4px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      justify-content: flex-start;
    }

    .footer {
      margin-top: 6px;
      font-size: 0.75rem;
      text-align: center;
      color: #777;
    }

    /* Fullscreen (app-level) */
    .fullscreen .toolbar-row,
    .fullscreen .page-controls,
    .fullscreen .note-meta,
    .fullscreen .search-row,
    .fullscreen .export-import-row,
    .fullscreen .audio-section,
    .fullscreen .footer,
    .fullscreen .notebook-bar {
      display: none;
    }
    .fullscreen .fullscreen-topbar {
      display: block;
    }
    .fullscreen .notebook-wrapper {
      height: calc(100vh - 60px);
    }

    @media (max-width: 600px) {
      .toolbar-row,
      .page-controls,
      .notebook-bar {
        flex-direction: column;
        align-items: stretch;
      }
      button {
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <h1>Handwritten Notebook</h1>
  <div class="app-container">
    <div id="fullscreenTopBar" class="fullscreen-topbar">
      Tap here to show toolbar / exit full screen
    </div>

    <!-- Notebook selector -->
    <div class="notebook-bar">
      <div class="toolbar-group">
        <span class="toolbar-label">Notebook</span>
        <select id="notebookSelect" class="notebook-select"></select>
        <button id="renameNotebookBtn" class="notebook-small-btn">Rename</button>
        <button id="deleteNotebookBtn" class="notebook-small-btn">Delete</button>
      </div>
      <button id="newNotebookBtn">+ New Notebook</button>
    </div>

    <!-- Top toolbar: tools + pen size -->
    <div class="toolbar-row">
      <div class="toolbar-group">
        <span class="toolbar-label">Tools</span>
        <button id="toolPen" class="active">‚úèÔ∏è Pen</button>
        <button id="toolHighlighter">üñç Highlighter</button>
        <button id="toolEraser">ü©π Eraser</button>
        <button id="undoBtn">‚Ü∂ Undo</button>
        <button id="redoBtn">‚Ü∑ Redo</button>
        <button id="clearPageBtn">üóë Clear Page</button>
      </div>
      <div class="toolbar-group">
        <span class="toolbar-label">Pen</span>
        <button data-color="black" class="color-btn active">
          <span class="color-dot color-black"></span> Black
        </button>
        <button data-color="blue" class="color-btn">
          <span class="color-dot color-blue"></span> Blue
        </button>
        <button data-color="red" class="color-btn">
          <span class="color-dot color-red"></span> Red
        </button>
        <button data-color="yellow" class="color-btn">
          <span class="color-dot color-yellow"></span> Yellow
        </button>
        <label class="toolbar-label">Size
          <!-- default pen size now 1 -->
          <input id="sizeSlider" type="range" min="1" max="15" value="1" />
        </label>
      </div>
    </div>

    <!-- Page controls -->
    <div class="page-controls">
      <div class="toolbar-group">
        <button id="prevPageBtn">‚óÄ Prev</button>
        <button id="nextPageBtn">Next ‚ñ∂</button>
        <button id="addPageBtn">‚ûï Add Page</button>
        <span class="page-info" id="pageInfo">Page 1 / 1</span>
      </div>
      <div class="toolbar-group">
        <input id="pageTitle" class="page-title-input" placeholder="Page title (optional)" />
        <button id="fullscreenToggleBtn">Full Screen</button>
      </div>
    </div>

    <!-- Notebook page -->
    <div class="notebook-wrapper">
      <div class="page-surface">
        <canvas id="drawingCanvas"></canvas>
      </div>
    </div>

    <!-- Text notes (for searchability) -->
    <div class="note-meta">
      <label for="pageText">Typed notes / keywords for this page (used for search):</label>
      <textarea id="pageText" placeholder="Optional: summary, keywords, or typed notes here..."></textarea>
    </div>

    <!-- Audio notes -->
    <div class="audio-section">
      <label>Audio Notes (per page):</label>
      <div class="audio-controls">
        <button id="startRecordBtn">Start Recording</button>
        <button id="stopRecordBtn" disabled>Stop</button>
        <span id="recordStatus">Recording status: Idle</span>

        <!-- Recording timer -->
        <span id="recordTimer" class="hint">00:00</span>

        <!-- Audio mode selector -->
        <label class="toolbar-label" style="margin-left:8px;">
          Mode
          <select id="audioMode" style="margin-left:4px; font-size:0.8rem; padding:2px 4px;">
            <option value="standard">Standard</option>
            <option value="enhanced">Enhanced (noise-reduced)</option>
          </select>
        </label>

        <!-- Hidden: global Save transcript button (kept for JS, not shown) -->
        <button id="saveTranscriptBtn" disabled style="display:none;">Save Transcript (.txt)</button>
      </div>

      <div id="audioList" class="audio-list"></div>
      <div id="audioHint" class="hint">
        üéô Audio recording uses your microphone. Support depends on your browser/device.
      </div>

      <!-- Live + final transcript area -->
      <div id="transcriptContainer" class="note-meta">
        <label for="liveTranscript">Live Transcript (this recording only):</label>
        <textarea id="liveTranscript" placeholder="Transcript will appear here while recording..." readonly></textarea>
        <label for="finalTranscript">Final Timestamped Transcript:</label>
        <textarea id="finalTranscript" placeholder="Final transcript with [hh:mm:ss] timestamps will appear here after you stop recording." readonly></textarea>
        <div id="transcriptStatus" class="hint">Speech recognition: idle</div>
      </div>
    </div>

    <!-- Search section -->
    <div class="search-row">
      <label for="searchInput">Search pages (by title or typed notes):</label>
      <input id="searchInput" class="search-input" type="text" placeholder="Type to search..." />
      <div id="searchResults" class="search-results"></div>
      <div class="hint">
        üîç Search currently works on the page title and typed notes, not on handwritten strokes.
      </div>
    </div>

    <!-- Export / Import / Restore -->
    <div class="export-import-row">
      <button id="exportBtn">‚¨áÔ∏è Export Notebook</button>
      <button id="importBtn">‚¨ÜÔ∏è Import Notebook</button>
      <button id="restoreBackupBtn">‚§¥ Restore Auto Backup</button>
      <span id="backupInfo" class="hint">Last auto backup: none yet</span>
      <input id="importFile" type="file" accept="application/json" style="display:none" />
    </div>

    <div class="footer">
      Notebook is stored locally in this browser using localStorage. You can close and reopen and continue where you left off.  
      Use Export/Import to back up or move to another browser.
    </div>
  </div>
  <script>
    // =====================================================
    //  Notebook core data + drawing
    // =====================================================
    const STORAGE_KEY = "handNotebook_v2";

    // Multi-notebook state
    let notebooks = [];
    let currentNotebookId = null;

    // Current notebook's pages (for drawing logic)
    let pages = [];
    let currentPageIndex = 0;

    const canvas = document.getElementById("drawingCanvas");
    const ctx = canvas.getContext("2d");

    let isDrawing = false;
    let currentStroke = null;

    const toolButtons = {
      pen: document.getElementById("toolPen"),
      highlighter: document.getElementById("toolHighlighter"),
      eraser: document.getElementById("toolEraser")
    };
    let currentTool = "pen";

    const sizeSlider = document.getElementById("sizeSlider");
    let currentSize = parseInt(sizeSlider.value, 10);

    let currentColor = "black";

    // palm-handling state
    let penActive = false;

    // Audio state
    let mediaRecorder = null;
    let recordedChunks = [];
    let currentStream = null;
    let isRecordingAudio = false;
    const audioSupported = !!(navigator.mediaDevices && window.MediaRecorder);

    const startRecordBtn = document.getElementById("startRecordBtn");
    const stopRecordBtn = document.getElementById("stopRecordBtn");
    const recordStatus = document.getElementById("recordStatus");
    const audioListEl = document.getElementById("audioList");
    const audioHintEl = document.getElementById("audioHint");
    const audioModeSelect = document.getElementById("audioMode");
    const recordTimerEl = document.getElementById("recordTimer");
    let recordTimerInterval = null;
    let recordStartTime = null;

    // Transcription DOM elements
    const saveTranscriptBtn = document.getElementById("saveTranscriptBtn");
    const liveTranscriptEl = document.getElementById("liveTranscript");
    const finalTranscriptEl = document.getElementById("finalTranscript");
    const transcriptStatusEl = document.getElementById("transcriptStatus");

    // Notebook UI
    const notebookSelect = document.getElementById("notebookSelect");
    const newNotebookBtn = document.getElementById("newNotebookBtn");
    const renameNotebookBtn = document.getElementById("renameNotebookBtn");
    const deleteNotebookBtn = document.getElementById("deleteNotebookBtn");

    // Fullscreen state
    const appContainer = document.querySelector(".app-container");
    const fullscreenTopBar = document.getElementById("fullscreenTopBar");
    const fullscreenToggleBtn = document.getElementById("fullscreenToggleBtn");
    let isFullscreenMode = false;

    // ---- Helpers for notebook/pages ----
    function createBlankPage() {
      return {
        id: Date.now() + Math.random(),
        title: "",
        text: "",
        strokes: [],
        undoStack: [],
        redoStack: [],
        audio: [] // {id, dataUrl, name, transcript}
      };
    }

    function createNotebook(name) {
      return {
        id: "nb_" + Date.now() + "_" + Math.random().toString(36).slice(2),
        name: name || `Notebook ${notebooks.length + 1}`,
        pages: [createBlankPage()],
        currentPageIndex: 0
      };
    }

    function getCurrentNotebook() {
      if (!notebooks.length) return null;
      if (!currentNotebookId) return notebooks[0];
      const nb = notebooks.find(n => n.id === currentNotebookId);
      return nb || notebooks[0];
    }

    function updateBackupInfo(fromTs) {
      const infoEl = document.getElementById("backupInfo");
      if (!infoEl) return;

      let ts = fromTs;
      if (!ts) {
        const metaRaw = localStorage.getItem(STORAGE_KEY + "_backup_meta");
        if (!metaRaw) {
          infoEl.textContent = "Last auto backup: none yet";
          return;
        }
        try {
          const meta = JSON.parse(metaRaw);
          ts = meta.ts;
        } catch (e) {
          infoEl.textContent = "Last auto backup: unknown";
          return;
        }
      }
      if (!ts) {
        infoEl.textContent = "Last auto backup: unknown";
        return;
      }
      const d = new Date(ts);
      infoEl.textContent = "Last auto backup: " + d.toLocaleString();
    }

    function saveNotebook() {
      const nb = getCurrentNotebook();
      if (nb) {
        nb.pages = pages;
        nb.currentPageIndex = currentPageIndex;
      }
      const data = {
        notebooks,
        currentNotebookId
      };
      try {
        const json = JSON.stringify(data);
        const nowIso = new Date().toISOString();
        // main storage
        localStorage.setItem(STORAGE_KEY, json);
        // newest-only backup
        localStorage.setItem(STORAGE_KEY + "_backup", json);
        localStorage.setItem(
          STORAGE_KEY + "_backup_meta",
          JSON.stringify({ ts: nowIso })
        );
        updateBackupInfo(nowIso);
      } catch (e) {
        console.warn("Could not save notebook:", e);
      }
    }

    // Helper to apply parsed data into our runtime structures
    function applyParsedNotebookData(parsed) {
      if (parsed.notebooks && Array.isArray(parsed.notebooks)) {
        notebooks = parsed.notebooks.map((n, idx) => {
          const rawPages = n.pages || [];
          const pageArr = rawPages.length
            ? rawPages.map(p => ({
                ...createBlankPage(),
                ...p,
                audio: p.audio || []
              }))
            : [createBlankPage()];

          return {
            id: n.id || "nb_" + Date.now() + "_" + idx,
            name: n.name || `Notebook ${idx + 1}`,
            pages: pageArr,
            currentPageIndex: Math.min(
              typeof n.currentPageIndex === "number" ? n.currentPageIndex : 0,
              pageArr.length - 1
            )
          };
        });

        if (!notebooks.length) {
          const nb = createNotebook("My Notebook");
          notebooks = [nb];
        }

        if (parsed.currentNotebookId &&
            notebooks.some(n => n.id === parsed.currentNotebookId)) {
          currentNotebookId = parsed.currentNotebookId;
        } else {
          currentNotebookId = notebooks[0].id;
        }
      } else if (parsed.pages && Array.isArray(parsed.pages)) {
        // Legacy single-notebook data -> wrap into one notebook
        const pageArr = parsed.pages.map(p => ({
          ...createBlankPage(),
          ...p,
          audio: p.audio || []
        }));
        const nb = createNotebook("My Notebook");
        nb.pages = pageArr.length ? pageArr : [createBlankPage()];
        nb.currentPageIndex = Math.min(
          typeof parsed.currentPageIndex === "number" ? parsed.currentPageIndex : 0,
          nb.pages.length - 1
        );
        notebooks = [nb];
        currentNotebookId = nb.id;
      } else {
        const nb = createNotebook("My Notebook");
        notebooks = [nb];
        currentNotebookId = nb.id;
      }

      const nb = getCurrentNotebook();
      if (nb) {
        pages = nb.pages;
        currentPageIndex = typeof nb.currentPageIndex === "number" ? nb.currentPageIndex : 0;
        if (!pages.length) {
          pages = [createBlankPage()];
          nb.pages = pages;
          currentPageIndex = 0;
          nb.currentPageIndex = 0;
        }
      } else {
        const nbNew = createNotebook("My Notebook");
        notebooks = [nbNew];
        currentNotebookId = nbNew.id;
        pages = nbNew.pages;
        currentPageIndex = nbNew.currentPageIndex;
      }
    }

    function loadNotebooks() {
      // Try primary first
      let raw = localStorage.getItem(STORAGE_KEY);

      // If missing, try backup
      if (!raw) {
        raw = localStorage.getItem(STORAGE_KEY + "_backup");
      }

      // If still missing ‚Üí create fresh default notebook
      if (!raw) {
        const nb = createNotebook("My Notebook");
        notebooks = [nb];
        currentNotebookId = nb.id;
        pages = nb.pages;
        currentPageIndex = nb.currentPageIndex;
        updateBackupInfo(); // will show "none yet"
        return;
      }

      try {
        const parsed = JSON.parse(raw);
        applyParsedNotebookData(parsed);
        updateBackupInfo(); // load from *_backup_meta if present
      } catch (e) {
        console.warn("Could not load notebook:", e);
        const nb = createNotebook("My Notebook");
        notebooks = [nb];
        currentNotebookId = nb.id;
        pages = nb.pages;
        currentPageIndex = nb.currentPageIndex;
        updateBackupInfo();
      }
    }

    function refreshNotebookSelect() {
      notebookSelect.innerHTML = "";
      notebooks.forEach(nb => {
        const opt = document.createElement("option");
        opt.value = nb.id;
        opt.textContent = nb.name;
        if (nb.id === currentNotebookId) {
          opt.selected = true;
        }
        notebookSelect.appendChild(opt);
      });
    }

    function switchNotebook(notebookId) {
      if (!notebookId || notebookId === currentNotebookId) return;

      const old = getCurrentNotebook();
      if (old) {
        old.pages = pages;
        old.currentPageIndex = currentPageIndex;
      }

      currentNotebookId = notebookId;
      const nb = getCurrentNotebook();
      if (!nb) return;

      pages = nb.pages;
      currentPageIndex = typeof nb.currentPageIndex === "number" ? nb.currentPageIndex : 0;
      if (!pages.length) {
        pages = [createBlankPage()];
        nb.pages = pages;
        currentPageIndex = 0;
        nb.currentPageIndex = 0;
      }

      refreshNotebookSelect();
      updatePageInfo();
      document.getElementById("pageTitle").value = pages[currentPageIndex].title || "";
      document.getElementById("pageText").value = pages[currentPageIndex].text || "";
      resizeCanvasToContainer();
      renderAudioList();
      saveNotebook();
    }

    function handleNewNotebook() {
      const name = prompt("Notebook name:", `Notebook ${notebooks.length + 1}`);
      if (name === null) return;
      const finalName = name.trim() || `Notebook ${notebooks.length + 1}`;
      const old = getCurrentNotebook();
      if (old) {
        old.pages = pages;
        old.currentPageIndex = currentPageIndex;
      }
      const nb = createNotebook(finalName);
      notebooks.push(nb);
      currentNotebookId = nb.id;
      pages = nb.pages;
      currentPageIndex = nb.currentPageIndex;
      refreshNotebookSelect();
      updatePageInfo();
      document.getElementById("pageTitle").value = "";
      document.getElementById("pageText").value = "";
      resizeCanvasToContainer();
      renderAudioList();
      saveNotebook();
    }

    function handleRenameNotebook() {
      const nb = getCurrentNotebook();
      if (!nb) return;
      const name = prompt("Rename notebook:", nb.name);
      if (name === null) return;
      const finalName = name.trim();
      if (!finalName) return;
      nb.name = finalName;
      refreshNotebookSelect();
      saveNotebook();
    }

    function handleDeleteNotebook() {
      if (notebooks.length <= 1) {
        alert("You must have at least one notebook.");
        return;
      }
      const nb = getCurrentNotebook();
      if (!nb) return;
      if (!confirm(`Delete notebook "${nb.name}"? This cannot be undone.`)) return;

      notebooks = notebooks.filter(n => n.id !== nb.id);
      currentNotebookId = notebooks[0].id;
      const newCurrent = getCurrentNotebook();
      pages = newCurrent.pages;
      currentPageIndex = typeof newCurrent.currentPageIndex === "number"
        ? newCurrent.currentPageIndex : 0;
      if (!pages.length) {
        pages = [createBlankPage()];
        newCurrent.pages = pages;
        currentPageIndex = 0;
        newCurrent.currentPageIndex = 0;
      }

      refreshNotebookSelect();
      updatePageInfo();
      document.getElementById("pageTitle").value = pages[currentPageIndex].title || "";
      document.getElementById("pageText").value = pages[currentPageIndex].text || "";
      resizeCanvasToContainer();
      renderAudioList();
      saveNotebook();
    }

    function updatePageInfo() {
      const info = document.getElementById("pageInfo");
      info.textContent = `Page ${currentPageIndex + 1} / ${pages.length || 1}`;
    }

    function resizeCanvasToContainer() {
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      redrawCurrentPage();
    }

    window.addEventListener("resize", () => {
      resizeCanvasToContainer();
    });

    // ---- Drawing logic ----
    function startStroke(x, y) {
      const page = pages[currentPageIndex];
      if (!page) return;

      page.redoStack = []; // new stroke invalidates redo history

      const normalizedPoint = normalizePoint(x, y);
      const stroke = {
        tool: currentTool, // 'pen', 'highlighter', 'eraser'
        color: currentColor,
        size: currentSize,
        points: [normalizedPoint]
      };
      currentStroke = stroke;
      page.strokes.push(stroke);
      isDrawing = true;
      redrawCurrentPage();
    }

    function addPointToStroke(x, y) {
      if (!isDrawing || !currentStroke) return;
      currentStroke.points.push(normalizePoint(x, y));
      redrawCurrentPage();
    }

    function endStroke() {
      if (!isDrawing) return;
      isDrawing = false;
      const page = pages[currentPageIndex];
      if (page && currentStroke && currentStroke.points.length > 0) {
        page.undoStack.push(currentStroke);
      }
      currentStroke = null;
      saveNotebook();
    }

    function normalizePoint(x, y) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: x / rect.width,
        y: y / rect.height
      };
    }

    function denormalizePoint(p) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: p.x * rect.width,
        y: p.y * rect.height
      };
    }

    function redrawCurrentPage() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const page = pages[currentPageIndex];
      if (!page) return;

      for (const stroke of page.strokes) {
        drawStroke(stroke);
      }
    }

    function drawStroke(stroke) {
      if (!stroke.points || stroke.points.length < 1) return;

      if (stroke.tool === "eraser") {
        ctx.globalCompositeOperation = "destination-out";
        ctx.lineWidth = stroke.size * 3; // thicker erase
        ctx.strokeStyle = "rgba(0,0,0,1)";
      } else if (stroke.tool === "highlighter") {
        ctx.globalCompositeOperation = "source-over";
        ctx.lineWidth = stroke.size * 3;
        // highlighter is always yellowish
        ctx.strokeStyle = "rgba(255, 235, 59, 0.45)";
      } else {
        ctx.globalCompositeOperation = "source-over";
        ctx.lineWidth = stroke.size * 2; // make pen clearer
        ctx.strokeStyle = getColorValue(stroke.color || "black");
      }

      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      ctx.beginPath();
      const first = denormalizePoint(stroke.points[0]);
      ctx.moveTo(first.x, first.y);
      for (let i = 1; i < stroke.points.length; i++) {
        const p = denormalizePoint(stroke.points[i]);
        ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
    }

    function getColorValue(name) {
      switch (name) {
        case "blue": return "#0052cc";
        case "red": return "#cc0000";
        case "yellow": return "#ffd54f";
        case "black":
        default:
          return "#000000";
      }
    }

    // ---- Undo / Redo / Clear ----
    function undo() {
      const page = pages[currentPageIndex];
      if (!page || page.strokes.length === 0) return;
      const stroke = page.strokes.pop();
      page.redoStack.push(stroke);
      redrawCurrentPage();
      saveNotebook();
    }

    function redo() {
      const page = pages[currentPageIndex];
      if (!page || page.redoStack.length === 0) return;
      const stroke = page.redoStack.pop();
      page.strokes.push(stroke);
      page.undoStack.push(stroke);
      redrawCurrentPage();
      saveNotebook();
    }

    function clearPage() {
      if (!confirm("Clear this entire page? This cannot be undone.")) return;
      const page = pages[currentPageIndex];
      page.strokes = [];
      page.undoStack = [];
      page.redoStack = [];
      redrawCurrentPage();
      saveNotebook();
    }

    // ---- Page navigation ----
    function goToPage(index) {
      if (index < 0 || index >= pages.length) return;
      currentPageIndex = index;
      const page = pages[currentPageIndex];
      document.getElementById("pageTitle").value = page.title || "";
      document.getElementById("pageText").value = page.text || "";
      updatePageInfo();
      resizeCanvasToContainer(); // this will also redraw
      renderAudioList();
      saveNotebook();
    }

    function addPage() {
      const newPage = createBlankPage();
      pages.push(newPage);
      goToPage(pages.length - 1);
    }

    // ---- Search ----
    function performSearch(query) {
      const resultsContainer = document.getElementById("searchResults");
      resultsContainer.innerHTML = "";
      const q = query.trim().toLowerCase();
      if (!q) return;

      pages.forEach((page, idx) => {
        const haystack = ((page.title || "") + " " + (page.text || "")).toLowerCase();
        if (haystack.includes(q)) {
          const btn = document.createElement("button");
          const title = page.title || `Untitled page ${idx + 1}`;
          btn.textContent = `Page ${idx + 1}: ${title}`;
          btn.addEventListener("click", () => {
            goToPage(idx);
          });
          resultsContainer.appendChild(btn);
        }
      });

      if (!resultsContainer.children.length) {
        resultsContainer.textContent = "No matches found.";
      }
    }

    // ---- UI setup ----
    function setActiveTool(tool) {
      currentTool = tool;
      Object.values(toolButtons).forEach(btn => btn.classList.remove("active"));
      if (tool === "pen") toolButtons.pen.classList.add("active");
      if (tool === "highlighter") toolButtons.highlighter.classList.add("active");
      if (tool === "eraser") toolButtons.eraser.classList.add("active");
    }

    function setActiveColor(color) {
      currentColor = color;
      document.querySelectorAll(".color-btn").forEach(btn => {
        btn.classList.toggle("active", btn.dataset.color === color);
      });
    }

    // ---- Pointer events (with palm handling) ----
    function getCanvasCoordinates(evt) {
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      return { x, y };
    }

    canvas.addEventListener("pointerdown", (evt) => {
      // basic palm rejection: if a pen stroke is active, ignore extra touches
      if (penActive && evt.pointerType === "touch") {
        return;
      }
      if (evt.pointerType === "pen") {
        penActive = true;
      }
      evt.preventDefault();
      const { x, y } = getCanvasCoordinates(evt);
      startStroke(x, y);
    });

    canvas.addEventListener("pointermove", (evt) => {
      if (!isDrawing) return;
      evt.preventDefault();
      const { x, y } = getCanvasCoordinates(evt);
      addPointToStroke(x, y);
    });

    canvas.addEventListener("pointerup", (evt) => {
      if (evt.pointerType === "pen") {
        penActive = false;
      }
      if (!isDrawing) return;
      evt.preventDefault();
      endStroke();
    });

    canvas.addEventListener("pointerleave", (evt) => {
      if (!isDrawing) return;
      if (evt.pointerType === "pen") {
        penActive = false;
      }
      endStroke();
    });

    canvas.addEventListener("pointercancel", (evt) => {
      if (evt.pointerType === "pen") {
        penActive = false;
      }
      if (isDrawing) {
        endStroke();
      }
    });

    // ==========================
    // Audio helpers
    // ==========================
    function dataUrlToBlob(dataUrl) {
      const parts = dataUrl.split(",");
      const match = parts[0].match(/:(.*?);/);
      const mime = match ? match[1] : "audio/webm";
      const binary = atob(parts[1]);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return new Blob([bytes], { type: mime });
    }

    // For future/offline transcription engine ‚Äì placeholder
    async function transcribeOfflineAudio(blob) {
      return "Transcription not supported for saved audio on this browser.";
    }

    // ==========================
    // Audio list renderer
    // ==========================
    function renderAudioList() {
      const page = pages[currentPageIndex];
      audioListEl.innerHTML = "";

      if (!page || !page.audio || !page.audio.length) {
        audioListEl.textContent = "No audio notes on this page yet.";
        return;
      }

      page.audio.forEach((clip, idx) => {
        const row = document.createElement("div");
        row.className = "audio-row";

        const audioEl = document.createElement("audio");
        audioEl.controls = true;

        try {
          const blob = dataUrlToBlob(clip.dataUrl);
          audioEl.src = URL.createObjectURL(blob);
        } catch (e) {
          audioEl.textContent = "Audio not supported.";
        }

        const labelSpan = document.createElement("span");
        labelSpan.textContent = clip.name || `Audio ${idx + 1}`;

        // Download audio
        const downloadBtn = document.createElement("button");
        downloadBtn.textContent = "Download";
        downloadBtn.addEventListener("click", () => {
          const safeName = (clip.name || `audio_${idx + 1}`).replace(/[^\w\- ]+/g, "_");
          const a = document.createElement("a");
          a.href = clip.dataUrl;
          a.download = safeName + ".webm";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
        });

        // Save transcript button (per audio)
        const saveTxtBtn = document.createElement("button");
        saveTxtBtn.textContent = "Save Transcript (.txt)";
        saveTxtBtn.addEventListener("click", () => {
          const transcript = clip.transcript || "";
          if (!transcript.trim()) {
            alert("No transcript was recorded for this audio.");
            return;
          }

          const safeName = (clip.name || `audio_${idx + 1}`).replace(/[^\w\- ]+/g, "_");
          const ts = new Date().toISOString().replace(/[:.]/g, "-");
          const blob = new Blob([transcript], { type: "text/plain" });

          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = safeName + "_" + ts + ".txt";

          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
        });

        // Delete audio
        const delBtn = document.createElement("button");
        delBtn.textContent = "Delete";
        delBtn.addEventListener("click", () => {
          if (!confirm("Delete this audio note?")) return;
          page.audio.splice(idx, 1);
          saveNotebook();
          renderAudioList();
        });

        row.appendChild(audioEl);
        row.appendChild(labelSpan);
        row.appendChild(downloadBtn);
        row.appendChild(saveTxtBtn);
        row.appendChild(delBtn);

        audioListEl.appendChild(row);
      });
    }

    // ==========================
    // Live Transcription (SpeechRecognition)
    // ==========================
    window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recogSupported = !!window.SpeechRecognition;
    let recognition = null;
    let isRecognizing = false;
    let finalTranscript = "";
    let transcriptSegments = [];
    let transcriptBaseTime = null;
    let autoRestartEnabled = true; // for continuous lecture-style capture
    let finalTimestampedTranscript = "";

    // Format seconds -> [HH:MM:SS]
    function formatTime(seconds) {
      let secs = Math.max(0, Math.floor(seconds || 0));
      const h = Math.floor(secs / 3600);
      const m = Math.floor((secs % 3600) / 60);
      const s = secs % 60;
      const hh = String(h).padStart(2, "0");
      const mm = String(m).padStart(2, "0");
      const ss = String(s).padStart(2, "0");
      return `[${hh}:${mm}:${ss}]`;
    }

    // Build final timestamped transcript from segments
    function buildTimestampedTranscript() {
      if (!transcriptSegments.length) {
        return (finalTranscript || "").trim();
      }
      const segs = transcriptSegments
        .filter(seg => seg && seg.text && seg.text.trim())
        .sort((a, b) => (a.start || 0) - (b.start || 0));

      const lines = segs.map(seg => {
        const t = formatTime(seg.start || 0);
        return `${t} ${seg.text.trim()}`;
      });
      return lines.join("\n");
    }

    function setupRecognition() {
      if (!recogSupported) {
        if (transcriptStatusEl) {
          transcriptStatusEl.textContent = "Speech recognition: not supported in this browser.";
        }
        if (saveTranscriptBtn) {
          saveTranscriptBtn.disabled = true;
        }
        return;
      }

      recognition = new window.SpeechRecognition();
      recognition.lang = "en-US";
      recognition.continuous = true;
      recognition.interimResults = true;

      recognition.onstart = () => {
        isRecognizing = true;
        if (transcriptStatusEl) {
          transcriptStatusEl.textContent = "Speech recognition: listening‚Ä¶";
        }
      };

      recognition.onresult = (event) => {
        let interim = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const res = event.results[i];
          const text = res[0].transcript;
          if (res.isFinal) {
            finalTranscript += text + " ";
            const now = (Date.now() - (transcriptBaseTime || Date.now())) / 1000;
            transcriptSegments.push({
              start: Math.max(now - 1.5, 0),
              end: now,
              text: text.trim()
            });
          } else {
            interim += text;
          }
        }

        if (liveTranscriptEl) {
          liveTranscriptEl.value = (finalTranscript || "").trim() + (interim ? "\n" + interim : "");
          liveTranscriptEl.scrollTop = liveTranscriptEl.scrollHeight;
        }
      };

      recognition.onerror = (e) => {
        console.error("SpeechRecognition error:", e);
        isRecognizing = false;
        if (transcriptStatusEl) {
          transcriptStatusEl.textContent = "Speech recognition error: " + e.error;
        }
        if (saveTranscriptBtn && (finalTranscript.trim() || finalTimestampedTranscript.trim())) {
          saveTranscriptBtn.disabled = false;
        }
        // If there's an error, stop auto-restart to avoid loops
        autoRestartEnabled = false;
      };

      recognition.onend = () => {
        isRecognizing = false;

        // If we're still recording audio, try to auto-resume listening (silence gap)
        if (isRecordingAudio && autoRestartEnabled) {
          if (transcriptStatusEl) {
            transcriptStatusEl.textContent = "Speech recognition: resuming‚Ä¶";
          }
          try {
            recognition.start();
            isRecognizing = true;
          } catch (err) {
            console.warn("Recognition restart failed:", err);
            autoRestartEnabled = false;
            if (transcriptStatusEl) {
              transcriptStatusEl.textContent = "Speech recognition stopped (cannot restart).";
            }
          }
        } else {
          if (transcriptStatusEl) {
            transcriptStatusEl.textContent = "Speech recognition: stopped.";
          }

          // When we are not actively recording, finalize timestamped transcript
          if (!isRecordingAudio) {
            finalTimestampedTranscript = buildTimestampedTranscript();
            if (finalTranscriptEl) {
              finalTranscriptEl.value = finalTimestampedTranscript || finalTranscript;
              finalTranscriptEl.scrollTop = finalTranscriptEl.scrollHeight;
            }
            if (saveTranscriptBtn && (finalTranscript.trim() || finalTimestampedTranscript.trim())) {
              saveTranscriptBtn.disabled = false;
            }
          }
        }
      };
    }

    // Optional global save transcript (live transcript) ‚Äì button is hidden
    if (saveTranscriptBtn) {
      saveTranscriptBtn.addEventListener("click", () => {
        const text = (finalTimestampedTranscript || finalTranscript || "").trim();
        if (!text) {
          alert("No transcript available yet.");
          return;
        }
        const blob = new Blob([text], { type: "text/plain" });
        const a = document.createElement("a");
        const ts = new Date().toISOString().replace(/[:.]/g, "-");
        a.href = URL.createObjectURL(blob);
        a.download = "notebook_transcript_" + ts + ".txt";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      });
    }

    // ==========================
    // Recording timer helper
    // ==========================
    function resetRecordTimer() {
      if (recordTimerInterval) {
        clearInterval(recordTimerInterval);
        recordTimerInterval = null;
      }
      recordStartTime = null;
      if (recordTimerEl) {
        recordTimerEl.textContent = "00:00";
      }
    }

    // ==========================
    // Enhanced recording + tie to transcription (Option 3 + Mic C)
    // ==========================
    async function startRecording() {
      if (!audioSupported || isRecordingAudio) return;
      try {
        // Choose constraints based on audio mode
        const mode = audioModeSelect ? audioModeSelect.value : "standard";

        // Extreme / far-mic tuned (C) ‚Äì both modes use strong speech-focused input
        let constraints;
        if (mode === "enhanced") {
          // More aggressive hints for browser audio pipeline
          constraints = {
            audio: {
              channelCount: 1,
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
              sampleRate: 48000,
              sampleSize: 16
            }
          };
        } else {
          // Still boosted, but slightly lighter
          constraints = {
            audio: {
              channelCount: 1,
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true
            }
          };
        }

        currentStream = await navigator.mediaDevices.getUserMedia(constraints);

        // Prefer high-quality Opus where supported
        let options = {};
        if (window.MediaRecorder && MediaRecorder.isTypeSupported) {
          if (MediaRecorder.isTypeSupported("audio/webm;codecs=opus")) {
            options.mimeType = "audio/webm;codecs=opus";
          } else if (MediaRecorder.isTypeSupported("audio/webm")) {
            options.mimeType = "audio/webm";
          } else if (MediaRecorder.isTypeSupported("audio/mp4")) {
            options.mimeType = "audio/mp4";
          }
        }

        mediaRecorder = new MediaRecorder(currentStream, options);
        recordedChunks = [];

        mediaRecorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) {
            recordedChunks.push(e.data);
          }
        };

        mediaRecorder.onstop = () => {
          // Audio recording finished
          startRecordBtn.disabled = false;
          stopRecordBtn.disabled = true;

          if (currentStream) {
            currentStream.getTracks().forEach(t => t.stop());
            currentStream = null;
          }

          resetRecordTimer();

          if (!recordedChunks.length) {
            recordStatus.textContent = "Recording status: No audio captured.";
            return;
          }

          const blob = new Blob(
            recordedChunks,
            { type: mediaRecorder.mimeType || "audio/webm" }
          );
          const reader = new FileReader();
          reader.onloadend = () => {
            const dataUrl = reader.result;
            const page = pages[currentPageIndex];
            if (!page.audio) page.audio = [];
            const name = `Audio ${page.audio.length + 1} (${new Date().toLocaleTimeString()})`;

            // Use timestamped transcript if available, otherwise raw
            const transcriptToSave = (finalTimestampedTranscript && finalTimestampedTranscript.trim())
              ? finalTimestampedTranscript
              : (finalTranscript || "").trim();

            page.audio.push({
              id: Date.now(),
              dataUrl,
              name,
              transcript: transcriptToSave
            });
            saveNotebook();
            renderAudioList();
            recordStatus.textContent = "Recording status: Saved.";
          };
          reader.readAsDataURL(blob);
        };

        // Reset transcript for this new recording session
        finalTranscript = "";
        transcriptSegments = [];
        finalTimestampedTranscript = "";
        autoRestartEnabled = true;

        if (liveTranscriptEl) liveTranscriptEl.value = "";
        if (finalTranscriptEl) finalTranscriptEl.value = "";
        if (transcriptStatusEl) transcriptStatusEl.textContent = "Speech recognition: starting‚Ä¶";
        if (saveTranscriptBtn) saveTranscriptBtn.disabled = true;

        // Start SpeechRecognition at same time (if supported)
        if (recogSupported && recognition) {
          transcriptBaseTime = Date.now();
          try {
            recognition.start();
          } catch (err) {
            console.warn("Recognition start failed:", err);
            autoRestartEnabled = false;
          }
        } else if (!recogSupported && transcriptStatusEl) {
          transcriptStatusEl.textContent = "Speech recognition not available in this browser.";
        }

        // Start media recording
        mediaRecorder.start(); // unlimited until you press Stop
        isRecordingAudio = true;
        startRecordBtn.disabled = true;
        stopRecordBtn.disabled = false;
        recordStatus.textContent =
          mode === "enhanced"
            ? "Recording status: Recording (enhanced)‚Ä¶"
            : "Recording status: Recording...";

        // Start recording timer
        resetRecordTimer();
        recordStartTime = Date.now();
        recordTimerInterval = setInterval(() => {
          if (!recordStartTime || !recordTimerEl) return;
          const secs = Math.floor((Date.now() - recordStartTime) / 1000);
          const mm = String(Math.floor(secs / 60)).padStart(2, "0");
          const ss = String(secs % 60).padStart(2, "0");
          recordTimerEl.textContent = `${mm}:${ss}`;
        }, 500);

      } catch (e) {
        console.error(e);
        isRecordingAudio = false;
        resetRecordTimer();
        recordStatus.textContent = "Recording status: Permission denied or error.";
      }
    }

    function stopRecording() {
      if (!isRecordingAudio || !mediaRecorder) return;
      // Mark recording as stopped BEFORE stopping recognition
      isRecordingAudio = false;
      autoRestartEnabled = false;
      recordStatus.textContent = "Recording status: Stopping...";
      resetRecordTimer();

      // Build final timestamped transcript now
      finalTimestampedTranscript = buildTimestampedTranscript();
      if (finalTranscriptEl) {
        finalTranscriptEl.value = finalTimestampedTranscript || finalTranscript;
        finalTranscriptEl.scrollTop = finalTranscriptEl.scrollHeight;
      }
      if (saveTranscriptBtn && (finalTranscript.trim() || finalTimestampedTranscript.trim())) {
        saveTranscriptBtn.disabled = false;
      }

      mediaRecorder.stop();

      // Also stop recognition if active
      if (recogSupported && recognition && isRecognizing) {
        try {
          recognition.stop();
        } catch (err) {
          console.warn("Recognition stop failed:", err);
        }
      }
    }

    function initAudio() {
      if (!audioSupported) {
        startRecordBtn.disabled = true;
        stopRecordBtn.disabled = true;
        recordStatus.textContent = "Recording status: Not supported in this browser.";
        audioHintEl.textContent = "Your browser does not support in-page audio recording.";
      } else {
        startRecordBtn.addEventListener("click", startRecording);
        stopRecordBtn.addEventListener("click", stopRecording);
      }

      // Init speech recognition
      setupRecognition();
    }

    // ---- Export / Import (full backup) ----
    const exportBtn = document.getElementById("exportBtn");
    const importBtn = document.getElementById("importBtn");
    const importFileInput = document.getElementById("importFile");
    const restoreBackupBtn = document.getElementById("restoreBackupBtn");

    exportBtn.addEventListener("click", () => {
      try {
        saveNotebook();

        const fullBackup = {
          notebooks,
          currentNotebookId,
          backupTimestamp: new Date().toISOString()
        };

        const json = JSON.stringify(fullBackup);

        // Save newest backup locally
        localStorage.setItem(STORAGE_KEY + "_backup", json);
        localStorage.setItem(
          STORAGE_KEY + "_backup_meta",
          JSON.stringify({ ts: fullBackup.backupTimestamp })
        );
        updateBackupInfo(fullBackup.backupTimestamp);

        // iOS-compatible download
        const base64 = btoa(unescape(encodeURIComponent(json)));
        const dataUrl = "data:application/json;base64," + base64;

        const a = document.createElement("a");
        a.href = dataUrl;

        const dateStr = fullBackup.backupTimestamp.replace(/[:.]/g, "-");
        a.download = `handwritten_notebook_FULL_${dateStr}.json`;

        document.body.appendChild(a);

        setTimeout(() => {
          a.click();
          document.body.removeChild(a);
        }, 100);

        alert("Full backup exported successfully.");
      } catch (e) {
        console.error(e);
        alert("Export failed.");
      }
    });

    importBtn.addEventListener("click", () => {
      importFileInput.click();
    });

    importFileInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (ev) => {
        try {
          const loaded = JSON.parse(ev.target.result);

          // must have full structure
          if (!loaded.notebooks || !Array.isArray(loaded.notebooks)) {
            throw new Error("Invalid full backup format");
          }

          notebooks = loaded.notebooks;
          currentNotebookId = loaded.currentNotebookId || notebooks[0].id;

          const nb = getCurrentNotebook();
          pages = nb.pages;
          currentPageIndex = nb.currentPageIndex ?? 0;

          refreshNotebookSelect();
          goToPage(currentPageIndex);
          saveNotebook();

          alert("‚úî Full backup restored successfully!");
        }
        catch (err) {
          console.error(err);
          alert("Could not import file. It may not be a valid FULL backup.");
        }
        finally {
          importFileInput.value = "";
        }
      };

      reader.readAsText(file);
    });

    // Restore from auto-backup stored in localStorage
    restoreBackupBtn.addEventListener("click", () => {
      const raw = localStorage.getItem(STORAGE_KEY + "_backup");
      if (!raw) {
        alert("No auto backup found in this browser yet.");
        return;
      }
      if (!confirm("Restore from last auto backup? This will overwrite the current notebooks stored in this browser.")) {
        return;
      }
      try {
        const parsed = JSON.parse(raw);
        applyParsedNotebookData(parsed);
        refreshNotebookSelect();
        updatePageInfo();
        document.getElementById("pageTitle").value = pages[currentPageIndex].title || "";
        document.getElementById("pageText").value = pages[currentPageIndex].text || "";
        resizeCanvasToContainer();
        renderAudioList();
        saveNotebook(); // also refreshes backup + timestamp
        alert("Restored from auto backup.");
      } catch (e) {
        console.error(e);
        alert("Backup data is invalid or corrupted.");
      }
    });

    // ---- Fullscreen (app-level) ----
    function enterFullscreen() {
      isFullscreenMode = true;
      appContainer.classList.add("fullscreen");
      fullscreenToggleBtn.textContent = "Exit Full Screen";
      resizeCanvasToContainer();
    }

    function exitFullscreen() {
      isFullscreenMode = false;
      appContainer.classList.remove("fullscreen");
      fullscreenToggleBtn.textContent = "Full Screen";
      resizeCanvasToContainer();
    }

    fullscreenToggleBtn.addEventListener("click", () => {
      if (isFullscreenMode) {
        exitFullscreen();
      } else {
        enterFullscreen();
      }
    });

    fullscreenTopBar.addEventListener("click", () => {
      if (isFullscreenMode) {
        exitFullscreen();
      }
    });

    // ---- Wire up controls ----
    document.getElementById("undoBtn").addEventListener("click", undo);
    document.getElementById("redoBtn").addEventListener("click", redo);
    document.getElementById("clearPageBtn").addEventListener("click", clearPage);

    toolButtons.pen.addEventListener("click", () => setActiveTool("pen"));
    toolButtons.highlighter.addEventListener("click", () => setActiveTool("highlighter"));
    toolButtons.eraser.addEventListener("click", () => setActiveTool("eraser"));

    document.querySelectorAll(".color-btn").forEach(btn => {
      btn.addEventListener("click", () => setActiveColor(btn.dataset.color));
    });

    sizeSlider.addEventListener("input", () => {
      currentSize = parseInt(sizeSlider.value, 10);
    });

    document.getElementById("prevPageBtn").addEventListener("click", () => {
      if (currentPageIndex > 0) goToPage(currentPageIndex - 1);
    });
    document.getElementById("nextPageBtn").addEventListener("click", () => {
      if (currentPageIndex < pages.length - 1) goToPage(currentPageIndex + 1);
    });
    document.getElementById("addPageBtn").addEventListener("click", addPage);

    document.getElementById("pageTitle").addEventListener("input", (e) => {
      const page = pages[currentPageIndex];
      page.title = e.target.value;
      saveNotebook();
    });

    document.getElementById("pageText").addEventListener("input", (e) => {
      const page = pages[currentPageIndex];
      page.text = e.target.value;
      saveNotebook();
    });

    document.getElementById("searchInput").addEventListener("input", (e) => {
      performSearch(e.target.value);
    });

    // Notebook selectors
    notebookSelect.addEventListener("change", (e) => {
      switchNotebook(e.target.value);
    });
    newNotebookBtn.addEventListener("click", handleNewNotebook);
    renameNotebookBtn.addEventListener("click", handleRenameNotebook);
    deleteNotebookBtn.addEventListener("click", handleDeleteNotebook);

    // ---- Init ----
    loadNotebooks();
    refreshNotebookSelect();
    updatePageInfo();
    document.getElementById("pageTitle").value = pages[currentPageIndex].title || "";
    document.getElementById("pageText").value = pages[currentPageIndex].text || "";
    resizeCanvasToContainer();
    setActiveTool(currentTool);
    setActiveColor(currentColor);
    renderAudioList();
    initAudio();
  </script>
</body>
</html>